{"version":3,"file":"mobx-react.module.js","sources":["../node_modules/mobx-react-lite/dist/index.module.js","../src/utils/utils.js","../src/observer.js","../src/Provider.js","../src/inject.js","../src/disposeOnUnmount.js","../src/propTypes.js","../src/index.js"],"sourcesContent":["import { spy, observable, computed, getDependencyTree, Reaction } from 'mobx';\nimport { useState, useRef, useMemo, useEffect, useCallback, useDebugValue, memo, forwardRef } from 'react';\n\nif (!useState) {\r\n    throw new Error(\"mobx-react-lite requires React with Hooks support\");\r\n}\r\nif (!spy) {\r\n    throw new Error(\"mobx-react-lite requires mobx at least version 4 to be available\");\r\n}\n\nfunction useObservable(initialValue) {\r\n    var observableRef = useRef(null);\r\n    if (!observableRef.current) {\r\n        observableRef.current = observable(initialValue);\r\n    }\r\n    return observableRef.current;\r\n}\n\nfunction useComputed(func, inputs) {\r\n    if (inputs === void 0) { inputs = []; }\r\n    var computed$$1 = useMemo(function () { return computed(func); }, inputs);\r\n    return computed$$1.get();\r\n}\n\nvar doNothingDisposer = function () {\r\n    // empty\r\n};\r\n/**\r\n * Adds an observable effect (reaction, autorun, or anything else that returns a disposer) that will be registered upon component creation and disposed upon unmounting.\r\n * Returns the generated disposer for early disposal.\r\n *\r\n * @export\r\n * @template D\r\n * @param {() => D} disposerGenerator A function that returns the disposer of the wanted effect.\r\n * @param {ReadonlyArray<any>} [inputs=[]] If you want the effect to be automatically re-created when some variable(s) are changed then pass them in this array.\r\n * @returns {D}\r\n */\r\nfunction useDisposable(disposerGenerator, inputs) {\r\n    if (inputs === void 0) { inputs = []; }\r\n    var disposerRef = useRef(null);\r\n    var earlyDisposedRef = useRef(false);\r\n    useEffect(function () {\r\n        return lazyCreateDisposer(false);\r\n    }, inputs);\r\n    function lazyCreateDisposer(earlyDisposal) {\r\n        // ensure that we won't create a new disposer if it was early disposed\r\n        if (earlyDisposedRef.current) {\r\n            return doNothingDisposer;\r\n        }\r\n        if (!disposerRef.current) {\r\n            var newDisposer = disposerGenerator();\r\n            if (typeof newDisposer !== \"function\") {\r\n                var error = new Error(\"generated disposer must be a function\");\r\n                {\r\n                    // tslint:disable-next-line:no-console\r\n                    console.error(error);\r\n                    return doNothingDisposer;\r\n                }\r\n            }\r\n            disposerRef.current = newDisposer;\r\n        }\r\n        return function () {\r\n            if (disposerRef.current) {\r\n                disposerRef.current();\r\n                disposerRef.current = null;\r\n            }\r\n            if (earlyDisposal) {\r\n                earlyDisposedRef.current = true;\r\n            }\r\n        };\r\n    }\r\n    return lazyCreateDisposer(true);\r\n}\n\nvar globalIsUsingStaticRendering = false;\r\nfunction useStaticRendering(enable) {\r\n    globalIsUsingStaticRendering = enable;\r\n}\r\nfunction isUsingStaticRendering() {\r\n    return globalIsUsingStaticRendering;\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\n\nfunction printDebugValue(v) {\r\n    if (!v.current) {\r\n        return \"<unknown>\";\r\n    }\r\n    return getDependencyTree(v.current);\r\n}\n\nvar EMPTY_ARRAY = [];\r\nfunction useUnmount(fn) {\r\n    useEffect(function () { return fn; }, EMPTY_ARRAY);\r\n}\r\nfunction useForceUpdate() {\r\n    var _a = __read(useState(0), 2), setTick = _a[1];\r\n    var update = useCallback(function () {\r\n        setTick(function (tick) { return tick + 1; });\r\n    }, []);\r\n    return update;\r\n}\n\nfunction useObserver(fn, baseComponentName) {\r\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\r\n    if (isUsingStaticRendering()) {\r\n        return fn();\r\n    }\r\n    var forceUpdate = useForceUpdate();\r\n    var reaction = useRef(null);\r\n    if (!reaction.current) {\r\n        reaction.current = new Reaction(\"observer(\" + baseComponentName + \")\", function () {\r\n            forceUpdate();\r\n        });\r\n    }\r\n    useDebugValue(reaction, printDebugValue);\r\n    useUnmount(function () {\r\n        reaction.current.dispose();\r\n    });\r\n    // render the original component, but have the\r\n    // reaction track the observables, so that rendering\r\n    // can be invalidated (see above) once a dependency changes\r\n    var rendering;\r\n    var exception;\r\n    reaction.current.track(function () {\r\n        try {\r\n            rendering = fn();\r\n        }\r\n        catch (e) {\r\n            exception = e;\r\n        }\r\n    });\r\n    if (exception) {\r\n        reaction.current.dispose();\r\n        throw exception; // re-throw any exceptions catched during rendering\r\n    }\r\n    return rendering;\r\n}\n\n// n.b. base case is not used for actual typings or exported in the typing files\r\nfunction observer(baseComponent, options) {\r\n    // The working of observer is explaind step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\r\n    if (isUsingStaticRendering()) {\r\n        return baseComponent;\r\n    }\r\n    var realOptions = __assign({ forwardRef: false }, options);\r\n    var baseComponentName = baseComponent.displayName || baseComponent.name;\r\n    var wrappedComponent = function (props, ref) {\r\n        return useObserver(function () { return baseComponent(props, ref); }, baseComponentName);\r\n    };\r\n    // memo; we are not intested in deep updates\r\n    // in props; we assume that if deep objects are changed,\r\n    // this is in observables, which would have been tracked anyway\r\n    var memoComponent;\r\n    if (realOptions.forwardRef) {\r\n        // we have to use forwardRef here because:\r\n        // 1. it cannot go before memo, only after it\r\n        // 2. forwardRef converts the function into an actual component, so we can't let the baseComponent do it\r\n        //    since it wouldn't be a callable function anymore\r\n        memoComponent = memo(forwardRef(wrappedComponent));\r\n    }\r\n    else {\r\n        memoComponent = memo(wrappedComponent);\r\n    }\r\n    copyStaticProperties(baseComponent, memoComponent);\r\n    memoComponent.displayName = baseComponentName;\r\n    return memoComponent;\r\n}\r\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\r\nvar hoistBlackList = {\r\n    $$typeof: true,\r\n    render: true,\r\n    compare: true,\r\n    type: true\r\n};\r\nfunction copyStaticProperties(base, target) {\r\n    Object.keys(base).forEach(function (key) {\r\n        if (base.hasOwnProperty(key) && !hoistBlackList[key]) {\r\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\r\n        }\r\n    });\r\n}\n\nfunction ObserverComponent(_a) {\r\n    var children = _a.children, render = _a.render;\r\n    var component = children || render;\r\n    if (typeof component !== \"function\") {\r\n        return null;\r\n    }\r\n    return useObserver(component);\r\n}\r\nObserverComponent.propTypes = {\r\n    children: ObserverPropsCheck,\r\n    render: ObserverPropsCheck\r\n};\r\nObserverComponent.displayName = \"Observer\";\r\nfunction ObserverPropsCheck(props, key, componentName, location, propFullName) {\r\n    var extraKey = key === \"children\" ? \"render\" : \"children\";\r\n    var hasProp = typeof props[key] === \"function\";\r\n    var hasExtraProp = typeof props[extraKey] === \"function\";\r\n    if (hasProp && hasExtraProp) {\r\n        return new Error(\"MobX Observer: Do not use children and render in the same time in`\" + componentName);\r\n    }\r\n    if (hasProp || hasExtraProp) {\r\n        return null;\r\n    }\r\n    return new Error(\"Invalid prop `\" +\r\n        propFullName +\r\n        \"` of type `\" +\r\n        typeof props[key] +\r\n        \"` supplied to\" +\r\n        \" `\" +\r\n        componentName +\r\n        \"`, expected `function`.\");\r\n}\n\nexport { useObservable, useComputed, useDisposable, isUsingStaticRendering, useStaticRendering, observer, useObserver, ObserverComponent as Observer };\n","export function isStateless(component) {\n    // `function() {}` has prototype, but `() => {}` doesn't\n    // `() => {}` via Babel has prototype too.\n    return !(component.prototype && component.prototype.render)\n}\n\nlet symbolId = 0\nfunction createSymbol(name) {\n    if (typeof Symbol === \"function\") {\n        return Symbol(name)\n    }\n    const symbol = `__$mobx-react ${name} (${symbolId})`\n    symbolId++\n    return symbol\n}\n\nconst createdSymbols = {}\nexport function newSymbol(name) {\n    if (!createdSymbols[name]) {\n        createdSymbols[name] = createSymbol(name)\n    }\n    return createdSymbols[name]\n}\n\nexport function shallowEqual(objA, objB) {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) return true\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false\n    }\n    const keysA = Object.keys(objA)\n    const keysB = Object.keys(objB)\n    if (keysA.length !== keysB.length) return false\n    for (let i = 0; i < keysA.length; i++) {\n        if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nconst hoistBlackList = {\n    $$typeof: 1,\n    render: 1,\n    compare: 1,\n    type: 1,\n    childContextTypes: 1,\n    contextType: 1,\n    contextTypes: 1,\n    defaultProps: 1,\n    getDefaultProps: 1,\n    getDerivedStateFromError: 1,\n    getDerivedStateFromProps: 1,\n    mixins: 1,\n    propTypes: 1\n}\n\nexport function copyStaticProperties(base, target) {\n    Object.keys(base).forEach(key => {\n        if (base.hasOwnProperty(key) && !hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key))\n        }\n    })\n}\n","import React, { Component, PureComponent, forwardRef } from \"react\"\nimport { createAtom, _allowStateChanges } from \"mobx\"\nimport {\n    observer as observerLite,\n    useStaticRendering as useStaticRenderingLite,\n    Observer\n} from \"mobx-react-lite\"\n\nimport { newSymbol, shallowEqual } from \"./utils/utils\"\n\nlet isUsingStaticRendering = false\n\nconst skipRenderKey = newSymbol(\"skipRender\")\nconst isForcingUpdateKey = newSymbol(\"isForcingUpdate\")\n\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nconst ReactForwardRefSymbol =\n    typeof forwardRef === \"function\" && forwardRef((_props, _ref) => {})[\"$$typeof\"]\n\n/**\n * Helper to set `prop` to `this` as non-enumerable (hidden prop)\n * @param target\n * @param prop\n * @param value\n */\nfunction setHiddenProp(target, prop, value) {\n    if (!Object.hasOwnProperty.call(target, prop)) {\n        Object.defineProperty(target, prop, {\n            enumerable: false,\n            configurable: true,\n            writable: true,\n            value\n        })\n    } else {\n        target[prop] = value\n    }\n}\n\nexport function useStaticRendering(useStaticRendering) {\n    isUsingStaticRendering = useStaticRendering\n    useStaticRenderingLite(useStaticRendering)\n}\n\nfunction observerSCU(nextProps, nextState) {\n    if (isUsingStaticRendering) {\n        console.warn(\n            \"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\"\n        )\n    }\n    // update on any state changes (as is the default)\n    if (this.state !== nextState) {\n        return true\n    }\n    // update if props are shallowly not equal, inspired by PureRenderMixin\n    // we could return just 'false' here, and avoid the `skipRender` checks etc\n    // however, it is nicer if lifecycle events are triggered like usually,\n    // so we return true here if props are shallowly modified.\n    return !shallowEqual(this.props, nextProps)\n}\n\nfunction makeObservableProp(target, propName) {\n    const valueHolderKey = newSymbol(`reactProp_${propName}_valueHolder`)\n    const atomHolderKey = newSymbol(`reactProp_${propName}_atomHolder`)\n    function getAtom() {\n        if (!this[atomHolderKey]) {\n            setHiddenProp(this, atomHolderKey, createAtom(\"reactive \" + propName))\n        }\n        return this[atomHolderKey]\n    }\n    Object.defineProperty(target, propName, {\n        configurable: true,\n        enumerable: true,\n        get: function() {\n            getAtom.call(this).reportObserved()\n            return this[valueHolderKey]\n        },\n        set: function set(v) {\n            if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v)) {\n                setHiddenProp(this, valueHolderKey, v)\n                setHiddenProp(this, skipRenderKey, true)\n                getAtom.call(this).reportChanged()\n                setHiddenProp(this, skipRenderKey, false)\n            } else {\n                setHiddenProp(this, valueHolderKey, v)\n            }\n        }\n    })\n}\n\n/**\n * Observer function / decorator\n */\nexport function observer(componentClass) {\n    if (componentClass.isMobxInjector === true) {\n        console.warn(\n            \"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\"\n        )\n    }\n\n    // TODO: still needed? (if func comp?)\n    // Unwrap forward refs into `<Observer>` component\n    // we need to unwrap the render, because it is the inner render that needs to be tracked,\n    // not the ForwardRef HoC\n    if (ReactForwardRefSymbol && componentClass[\"$$typeof\"] === ReactForwardRefSymbol) {\n        const baseRender = componentClass.render\n        if (typeof baseRender !== \"function\")\n            throw new Error(\"render property of ForwardRef was not a function\")\n        return forwardRef(function ObserverForwardRef() {\n            return <Observer>{() => baseRender.apply(undefined, arguments)}</Observer>\n        })\n    }\n\n    // Function component\n    if (\n        typeof componentClass === \"function\" &&\n        (!componentClass.prototype || !componentClass.prototype.render) &&\n        !componentClass.isReactClass &&\n        !Component.isPrototypeOf(componentClass)\n    ) {\n        return observerLite(componentClass)\n    }\n\n    return makeClassComponentObserver(componentClass)\n}\n\nfunction makeClassComponentObserver(componentClass) {\n    const target = componentClass.prototype || componentClass\n    if (target.componentWillReact)\n        throw new Error(\"The componentWillReact life-cycle event is no longer supported\")\n    if (componentClass.__proto__ !== PureComponent) {\n        if (!target.shouldComponentUpdate) target.shouldComponentUpdate = observerSCU\n        else if (target.shouldComponentUpdate !== observerSCU)\n            throw new Error(\n                \"It is not allowed to use shouldComponentUpdate in observer based components.\"\n            )\n    }\n    makeObservableProp(target, \"props\")\n    makeObservableProp(target, \"state\")\n    const baseRender = target.render\n\n    target.render = function renderWrapper() {\n        if (!this.baseRender) {\n            // safe the closure, as it won't change!\n            const bound = baseRender.bind(this)\n            this.baseRender = () => bound()\n        }\n        return <Observer>{this.baseRender}</Observer>\n    }\n    return componentClass\n}\n","import { Children, Component, createContext, createElement } from \"react\"\nimport { shallowEqual } from \"./utils/utils\"\n\nconst specialReactKeys = { children: true, key: true, ref: true }\n\nexport const MobXProviderContext = createContext({})\n\nexport class Provider extends Component {\n    static contextType = MobXProviderContext\n\n    constructor(props, context) {\n        super(props, context)\n        this.state = {\n            ...context,\n            ...grabStores(props)\n        }\n    }\n\n    render() {\n        return createElement(\n            MobXProviderContext.Provider,\n            { value: this.state },\n            Children.only(this.props.children)\n        )\n    }\n\n    static getDerivedStateFromProps(nextProps, prevState) {\n        const newStores = { ...prevState, ...grabStores(nextProps) } // spread in prevState for the context based stores\n        if (!shallowEqual(prevState, newStores))\n            throw new Error(\n                \"MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children\"\n            )\n        return prevState // because they didn't change, remember!\n    }\n}\n\nfunction grabStores(from) {\n    const res = {}\n    if (!from) return res\n    for (let key in from) if (validStoreName(key)) res[key] = from[key]\n    return res\n}\n\nfunction validStoreName(key) {\n    return !specialReactKeys[key] && key !== \"suppressChangedStoreWarning\"\n}\n","import React, { Component, createElement } from \"react\"\nimport { observer } from \"./observer\"\nimport { isStateless, copyStaticProperties } from \"./utils/utils\"\nimport { MobXProviderContext } from \"./Provider\"\n\n/**\n * Store Injection\n */\nfunction createStoreInjector(grabStoresFn, component, injectNames, makeReactive) {\n    let displayName = getInjectName(component, injectNames)\n\n    class Injector extends Component {\n        static contextType = MobXProviderContext\n\n        render() {\n            const { forwardRef, ...props } = this.props\n\n            Object.assign(props, grabStoresFn(this.context || {}, props) || {})\n\n            if (forwardRef && !isStateless(component)) {\n                props.ref = this.props.forwardRef\n            }\n\n            return createElement(component, props)\n        }\n    }\n    if (makeReactive) Injector = observer(Injector)\n    Injector.isMobxInjector = true // assigned late to suppress observer warning\n\n    // Support forward refs\n    const InjectHocRef = React.forwardRef((props, ref) =>\n        React.createElement(Injector, { ...props, forwardRef: ref })\n    )\n    // Static fields from component should be visible on the generated Injector\n    copyStaticProperties(component, InjectHocRef)\n    InjectHocRef.wrappedComponent = component\n    InjectHocRef.displayName = displayName\n    return InjectHocRef\n}\n\nfunction getInjectName(component, injectNames) {\n    let displayName\n    const componentName =\n        component.displayName ||\n        component.name ||\n        (component.constructor && component.constructor.name) ||\n        \"Component\"\n    if (injectNames) displayName = \"inject-with-\" + injectNames + \"(\" + componentName + \")\"\n    else displayName = \"inject(\" + componentName + \")\"\n    return displayName\n}\n\nfunction grabStoresByName(storeNames) {\n    return function(baseStores, nextProps) {\n        storeNames.forEach(function(storeName) {\n            if (\n                storeName in nextProps // prefer props over stores\n            )\n                return\n            if (!(storeName in baseStores))\n                throw new Error(\n                    \"MobX injector: Store '\" +\n                        storeName +\n                        \"' is not available! Make sure it is provided by some Provider\"\n                )\n            nextProps[storeName] = baseStores[storeName]\n        })\n        return nextProps\n    }\n}\n\n/**\n * higher order component that injects stores to a child.\n * takes either a varargs list of strings, which are stores read from the context,\n * or a function that manually maps the available stores from the context to props:\n * storesToProps(mobxStores, props, context) => newProps\n */\nexport function inject(/* fn(stores, nextProps) or ...storeNames */ ...storeNames) {\n    let grabStoresFn\n    if (typeof arguments[0] === \"function\") {\n        grabStoresFn = arguments[0]\n        return componentClass =>\n            createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true)\n    } else {\n        return componentClass =>\n            createStoreInjector(\n                grabStoresByName(storeNames),\n                componentClass,\n                storeNames.join(\"-\"),\n                false\n            )\n    }\n}\n","import * as React from \"react\"\nimport { newSymbol } from \"./utils/utils\"\n\nconst storeKey = newSymbol(\"disposeOnUnmount\")\nconst baseUnmountKey = newSymbol(\"originalOnUnmount\")\n\nfunction runDisposersOnWillUnmount() {\n    if (this[baseUnmountKey]) this[baseUnmountKey]()\n    if (!this[storeKey]) {\n        // when disposeOnUnmount is only set to some instances of a component it will still patch the prototype\n        return\n    }\n    this[storeKey].forEach(propKeyOrFunction => {\n        const prop =\n            typeof propKeyOrFunction === \"string\" ? this[propKeyOrFunction] : propKeyOrFunction\n        if (prop !== undefined && prop !== null) {\n            if (typeof prop !== \"function\") {\n                throw new Error(\n                    \"[mobx-react] disposeOnUnmount only works on functions such as disposers returned by reactions, autorun, etc.\"\n                )\n            }\n            prop()\n        }\n    })\n    this[storeKey] = []\n}\n\nexport function disposeOnUnmount(target, propertyKeyOrFunction) {\n    if (Array.isArray(propertyKeyOrFunction)) {\n        return propertyKeyOrFunction.map(fn => disposeOnUnmount(target, fn))\n    }\n\n    const c = Object.getPrototypeOf(target).constructor || Object.getPrototypeOf(target.constructor)\n    const c2 = Object.getPrototypeOf(target.constructor)\n    if (\n        !(\n            c === React.Component ||\n            c === React.PureComponent ||\n            c2 === React.Component ||\n            c2 === React.PureComponent\n        )\n    ) {\n        throw new Error(\n            \"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\"\n        )\n    }\n\n    if (typeof propertyKeyOrFunction !== \"string\" && typeof propertyKeyOrFunction !== \"function\") {\n        throw new Error(\n            \"[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.\"\n        )\n    }\n\n    // add property key / function we want run (disposed) to the store\n    const componentWasAlreadyModified = !!target[storeKey]\n    const store = target[storeKey] || (target[storeKey] = [])\n    store.push(propertyKeyOrFunction)\n\n    // tweak the component class componentWillUnmount if not done already\n    if (!componentWasAlreadyModified) {\n        // make sure original definition is invoked\n        if (target.componentWillUnmount) target[baseUnmountKey] = target.componentWillUnmount\n\n        Object.defineProperty(target, \"componentWillUnmount\", {\n            get() {\n                return runDisposersOnWillUnmount\n            },\n            set(fn) {\n                // this will happen if componentWillUnmount is being assigned after patching the prototype\n                this[storeKey].push(fn)\n                // assigning a new local value to componentWillUnmount would hide the super implementation...\n                this[baseUnmountKey] = undefined\n            },\n            configurable: false,\n            enumerable: false\n        })\n    }\n\n    // return the disposer as is if invoked as a non decorator\n    if (typeof propertyKeyOrFunction !== \"string\") {\n        return propertyKeyOrFunction\n    }\n}\n","import { isObservableArray, isObservableObject, isObservableMap, untracked } from \"mobx\"\n\n// TODO: can we just import this stuff?\n// Copied from React.PropTypes\nfunction createChainableTypeChecker(validate) {\n    function checkType(\n        isRequired,\n        props,\n        propName,\n        componentName,\n        location,\n        propFullName,\n        ...rest\n    ) {\n        return untracked(() => {\n            componentName = componentName || \"<<anonymous>>\"\n            propFullName = propFullName || propName\n            if (props[propName] == null) {\n                if (isRequired) {\n                    const actual = props[propName] === null ? \"null\" : \"undefined\"\n                    return new Error(\n                        \"The \" +\n                            location +\n                            \" `\" +\n                            propFullName +\n                            \"` is marked as required \" +\n                            \"in `\" +\n                            componentName +\n                            \"`, but its value is `\" +\n                            actual +\n                            \"`.\"\n                    )\n                }\n                return null\n            } else {\n                return validate(props, propName, componentName, location, propFullName, ...rest)\n            }\n        })\n    }\n\n    const chainedCheckType = checkType.bind(null, false)\n    chainedCheckType.isRequired = checkType.bind(null, true)\n    return chainedCheckType\n}\n\n// Copied from React.PropTypes\nfunction isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === \"symbol\") {\n        return true\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n        return true\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n        return true\n    }\n\n    return false\n}\n\n// Copied from React.PropTypes\nfunction getPropType(propValue) {\n    const propType = typeof propValue\n    if (Array.isArray(propValue)) {\n        return \"array\"\n    }\n    if (propValue instanceof RegExp) {\n        // Old webkits (at least until Android 4.0) return 'function' rather than\n        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n        // passes PropTypes.object.\n        return \"object\"\n    }\n    if (isSymbol(propType, propValue)) {\n        return \"symbol\"\n    }\n    return propType\n}\n\n// This handles more types than `getPropType`. Only used for error messages.\n// Copied from React.PropTypes\nfunction getPreciseType(propValue) {\n    const propType = getPropType(propValue)\n    if (propType === \"object\") {\n        if (propValue instanceof Date) {\n            return \"date\"\n        } else if (propValue instanceof RegExp) {\n            return \"regexp\"\n        }\n    }\n    return propType\n}\n\nfunction createObservableTypeCheckerCreator(allowNativeType, mobxType) {\n    return createChainableTypeChecker(function(\n        props,\n        propName,\n        componentName,\n        location,\n        propFullName\n    ) {\n        return untracked(() => {\n            if (allowNativeType) {\n                if (getPropType(props[propName]) === mobxType.toLowerCase()) return null\n            }\n            let mobxChecker\n            switch (mobxType) {\n                case \"Array\":\n                    mobxChecker = isObservableArray\n                    break\n                case \"Object\":\n                    mobxChecker = isObservableObject\n                    break\n                case \"Map\":\n                    mobxChecker = isObservableMap\n                    break\n                default:\n                    throw new Error(`Unexpected mobxType: ${mobxType}`)\n            }\n            const propValue = props[propName]\n            if (!mobxChecker(propValue)) {\n                const preciseType = getPreciseType(propValue)\n                const nativeTypeExpectationMessage = allowNativeType\n                    ? \" or javascript `\" + mobxType.toLowerCase() + \"`\"\n                    : \"\"\n                return new Error(\n                    \"Invalid prop `\" +\n                        propFullName +\n                        \"` of type `\" +\n                        preciseType +\n                        \"` supplied to\" +\n                        \" `\" +\n                        componentName +\n                        \"`, expected `mobx.Observable\" +\n                        mobxType +\n                        \"`\" +\n                        nativeTypeExpectationMessage +\n                        \".\"\n                )\n            }\n            return null\n        })\n    })\n}\n\nfunction createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {\n    return createChainableTypeChecker(function(\n        props,\n        propName,\n        componentName,\n        location,\n        propFullName,\n        ...rest\n    ) {\n        return untracked(() => {\n            if (typeof typeChecker !== \"function\") {\n                return new Error(\n                    \"Property `\" +\n                        propFullName +\n                        \"` of component `\" +\n                        componentName +\n                        \"` has \" +\n                        \"invalid PropType notation.\"\n                )\n            }\n            let error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(\n                props,\n                propName,\n                componentName\n            )\n            if (error instanceof Error) return error\n            const propValue = props[propName]\n            for (let i = 0; i < propValue.length; i++) {\n                error = typeChecker(\n                    propValue,\n                    i,\n                    componentName,\n                    location,\n                    propFullName + \"[\" + i + \"]\",\n                    ...rest\n                )\n                if (error instanceof Error) return error\n            }\n            return null\n        })\n    })\n}\n\nconst observableArray = createObservableTypeCheckerCreator(false, \"Array\")\nconst observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false)\nconst observableMap = createObservableTypeCheckerCreator(false, \"Map\")\nconst observableObject = createObservableTypeCheckerCreator(false, \"Object\")\nconst arrayOrObservableArray = createObservableTypeCheckerCreator(true, \"Array\")\nconst arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true)\nconst objectOrObservableObject = createObservableTypeCheckerCreator(true, \"Object\")\n\nexport const PropTypes = {\n    observableArray,\n    observableArrayOf,\n    observableMap,\n    observableObject,\n    arrayOrObservableArray,\n    arrayOrObservableArrayOf,\n    objectOrObservableObject\n}\n","import { observable, configure } from \"mobx\"\nimport { Component } from \"react\"\nimport { unstable_batchedUpdates as rdBatched } from \"react-dom\"\n\nif (!Component) throw new Error(\"mobx-react requires React to be available\")\nif (!observable) throw new Error(\"mobx-react requires mobx to be available\")\n\nif (typeof rdBatched === \"function\") configure({ reactionScheduler: rdBatched })\n\nexport { useObservable, useComputed, useDisposable, useObserver, Observer } from \"mobx-react-lite\"\n\nexport { observer, useStaticRendering } from \"./observer\"\n\nexport { Provider } from \"./Provider\"\nexport { inject } from \"./inject\"\nexport { disposeOnUnmount } from \"./disposeOnUnmount\"\nexport { PropTypes } from \"./propTypes\"\n"],"names":["useState","Error","spy","useObservable","initialValue","observableRef","useRef","current","observable","useComputed","func","inputs","useMemo","computed","get","doNothingDisposer","useDisposable","disposerGenerator","disposerRef","earlyDisposedRef","lazyCreateDisposer","earlyDisposal","newDisposer","error","console","useEffect","globalIsUsingStaticRendering","isUsingStaticRendering","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","printDebugValue","v","getDependencyTree","EMPTY_ARRAY","useObserver","fn","baseComponentName","rendering","exception","setTick","forceUpdate","o","m","Symbol","iterator","r","e","ar","next","done","push","value","__read","useCallback","tick","reaction","Reaction","useDebugValue","useUnmount","dispose","track","hoistBlackList","$$typeof","render","compare","type","ObserverComponent","_a","component","children","ObserverPropsCheck","props","key","componentName","location","propFullName","hasProp","hasExtraProp","propTypes","displayName","let","symbolId","createdSymbols","newSymbol","name","symbol","createSymbol","shallowEqual","objA","objB","is","keysA","keys","keysB","x","y","const","childContextTypes","contextType","contextTypes","defaultProps","getDefaultProps","getDerivedStateFromError","getDerivedStateFromProps","mixins","skipRenderKey","isForcingUpdateKey","ReactForwardRefSymbol","forwardRef","_props","_ref","setHiddenProp","target","prop","defineProperty","enumerable","configurable","writable","useStaticRendering","observerSCU","nextProps","nextState","warn","state","makeObservableProp","propName","valueHolderKey","atomHolderKey","getAtom","createAtom","reportObserved","set","reportChanged","observer","componentClass","isMobxInjector","baseRender","React","Observer","undefined","isReactClass","Component","isPrototypeOf","componentWillReact","__proto__","PureComponent","shouldComponentUpdate","bound","bind","makeClassComponentObserver","baseComponent","options","memoComponent","base","realOptions","observerLite","wrappedComponent","ref","memo","forEach","getOwnPropertyDescriptor","specialReactKeys","MobXProviderContext","createContext","Provider","constructor","context","grabStores","createElement","Children","only","prevState","from","res","validStoreName","createStoreInjector","grabStoresFn","injectNames","makeReactive","getInjectName","Injector","isStateless","InjectHocRef","inject","storeNames","baseStores","storeName","grabStoresByName","join","storeKey","baseUnmountKey","runDisposersOnWillUnmount","propKeyOrFunction","disposeOnUnmount","propertyKeyOrFunction","Array","isArray","map","c","getPrototypeOf","c2","componentWasAlreadyModified","componentWillUnmount","createChainableTypeChecker","validate","checkType","isRequired","untracked","rest","chainedCheckType","getPropType","propValue","propType","RegExp","isSymbol","createObservableTypeCheckerCreator","allowNativeType","mobxType","toLowerCase","mobxChecker","isObservableArray","isObservableObject","isObservableMap","preciseType","Date","getPreciseType","nativeTypeExpectationMessage","createObservableArrayOfTypeChecker","typeChecker","PropTypes","rdBatched","configure","reactionScheduler"],"mappings":"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"}