{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/* eslint-disable react-hooks/exhaustive-deps */\n\n\nimport Validator from 'async-validator';\nimport { get, merge } from 'lodash-es';\nimport { allPromiseFinish, dataToKeys, destructDataPath, getDataPath, getDescriptorSimple, isExpression, isObject, parseSingleExpression, removeDups } from './utils';\nimport { defaultValidateMessages } from './validateMessage';\nimport { defaultValidateMessagesCN } from './validateMessageCN';\nexport var parseSchemaExpression = function parseSchemaExpression(schema, formData, path) {\n  if (!isObject(schema)) return schema;\n  var result = {};\n  Object.keys(schema).forEach(function (key) {\n    var item = schema[key];\n\n    if (isObject(item)) {\n      result[key] = parseSchemaExpression(item, formData, path);\n    } else if (isExpression(item)) {\n      result[key] = parseSingleExpression(item, formData, path);\n    } else {\n      result[key] = item;\n    }\n  });\n  return result;\n};\n\nvar getRelatedPaths = function getRelatedPaths(path, flatten) {\n  var parentPaths = [];\n  var pathArr = path.split('.');\n\n  while (pathArr.length > 0) {\n    parentPaths.push(pathArr.join('.'));\n    pathArr.pop();\n  }\n\n  var result = [].concat(parentPaths);\n  parentPaths.forEach(function (path) {\n    var _destructDataPath = destructDataPath(path),\n        id = _destructDataPath.id,\n        dataIndex = _destructDataPath.dataIndex;\n\n    if (flatten[id] && flatten[id].schema && Array.isArray(flatten[id].schema.dependecies)) {\n      var deps = flatten[id].schema.dependecies;\n      var fullPathDeps = deps.map(function (dep) {\n        return getDataPath(dep, dataIndex);\n      });\n      result = [].concat(_toConsumableArray(result), _toConsumableArray(fullPathDeps));\n    }\n  });\n  return removeDups(result).map(function (path) {\n    if (path.slice(-1) === ']') {\n      var pattern = /\\[[0-9]+\\]$/;\n      return path.replace(pattern, '');\n    } else {\n      return path;\n    }\n  });\n};\n\nexport var validateField = function validateField(_ref) {\n  var path = _ref.path,\n      formData = _ref.formData,\n      flatten = _ref.flatten,\n      options = _ref.options;\n  var paths = getRelatedPaths(path, flatten); // console.log('all relevant paths:', paths);\n\n  var promiseArray = paths.map(function (path) {\n    var _destructDataPath2 = destructDataPath(path),\n        id = _destructDataPath2.id,\n        dataIndex = _destructDataPath2.dataIndex;\n\n    if (flatten[id] || flatten[\"\".concat(id, \"[]\")]) {\n      var item = flatten[id] || flatten[\"\".concat(id, \"[]\")];\n      var singleData = get(formData, path);\n      var schema = item.schema || {};\n      var finalSchema = parseSchemaExpression(schema, formData, path);\n      return validateSingle(singleData, finalSchema, path, options); // is a promise\n    } else {\n      return Promise.resolve();\n    }\n  });\n  return allPromiseFinish(promiseArray).then(function (res) {\n    var errorFields = res.filter(function (item) {\n      return Array.isArray(item) && item.length > 0;\n    }).map(function (item) {\n      var name = item[0].field;\n      var error = item.map(function (m) {\n        return m.message;\n      }).filter(function (m) {\n        return !!m;\n      });\n      return {\n        name: name,\n        error: error\n      };\n    });\n    return errorFields;\n  }).catch(function (e) {\n    console.log(e);\n  });\n}; // pathFromData => allPath\n\nvar getAllPaths = function getAllPaths(paths, flatten) {\n  if (!Array.isArray(paths)) return [];\n\n  var result = _toConsumableArray(paths).filter(function (p) {\n    return p.indexOf(']') > -1;\n  }).map(function (p1) {\n    var last = p1.lastIndexOf(']');\n    return p1.substring(0, last + 1);\n  });\n\n  var uniqueResult = removeDups(result);\n  var allFlattenPath = Object.keys(flatten);\n\n  var res = _toConsumableArray(paths);\n\n  uniqueResult.forEach(function (result) {\n    var _destructDataPath3 = destructDataPath(result),\n        id = _destructDataPath3.id,\n        dataIndex = _destructDataPath3.dataIndex;\n\n    if (flatten[id]) {\n      var children = allFlattenPath.filter(function (f) {\n        return f.indexOf(id) === 0 && f !== id;\n      });\n      var childrenWithIndex = children.map(function (child) {\n        var p = getDataPath(child, dataIndex);\n        return p.split('[]')[0];\n      }).filter(function (i) {\n        return !!i;\n      });\n      res = [].concat(_toConsumableArray(res), _toConsumableArray(removeDups(childrenWithIndex)));\n    }\n  });\n  return removeDups(res);\n};\n\nexport var validateAll = function validateAll(_ref2) {\n  var formData = _ref2.formData,\n      flatten = _ref2.flatten,\n      options = _ref2.options;\n  var paths = dataToKeys(formData);\n  var allPaths = getAllPaths(paths, flatten); // console.log(formData, dataToKeys(formData), 'dataToKeysdataToKeys');\n  // console.log('allPaths', allPaths);\n\n  var promiseArray = allPaths.map(function (path) {\n    var _destructDataPath4 = destructDataPath(path),\n        id = _destructDataPath4.id,\n        dataIndex = _destructDataPath4.dataIndex;\n\n    if (flatten[id] || flatten[\"\".concat(id, \"[]\")]) {\n      var item = flatten[id] || flatten[\"\".concat(id, \"[]\")];\n      var singleData = get(formData, path);\n      var schema = item.schema || {}; // 若parent的hidden属性为true，则子项需继承 hidden\n\n      var relatedPaths = getRelatedPaths(path, flatten);\n\n      if (relatedPaths.length > 1) {\n        var parentPath = relatedPaths[relatedPaths.length - 1];\n        var parentSchema = flatten[parentPath] || {};\n\n        if (get(parentSchema, 'schema.hidden', false)) {\n          schema.hidden = true;\n        }\n      }\n\n      var finalSchema = parseSchemaExpression(schema, formData, path);\n      return validateSingle(singleData, finalSchema, path, options); // is a promise\n    } else {\n      return Promise.resolve();\n    }\n  });\n  return allPromiseFinish(promiseArray).then(function (res) {\n    var errorFields = res.filter(function (item) {\n      return Array.isArray(item) && item.length > 0 && item[0].message !== null;\n    }) // NOTICE: different from validateField\n    .map(function (item) {\n      var name = item[0].field;\n      var error = item.map(function (m) {\n        return m.message;\n      }).filter(function (m) {\n        return !!m;\n      });\n      return {\n        name: name,\n        error: error\n      };\n    });\n    return errorFields;\n  }).catch(function (e) {\n    console.log(e);\n  });\n};\n\nvar validateSingle = function validateSingle(data) {\n  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var path = arguments.length > 2 ? arguments[2] : undefined;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (schema.hidden) {\n    return Promise.resolve();\n  }\n\n  var _options$validateMess = options.validateMessages,\n      validateMessages = _options$validateMess === void 0 ? {} : _options$validateMess,\n      _options$locale = options.locale,\n      locale = _options$locale === void 0 ? 'cn' : _options$locale;\n  var cn = defaultValidateMessagesCN;\n  var en = defaultValidateMessages;\n  var descriptor = getDescriptorSimple(schema, path); // console.log('descriptor, schema, path', descriptor, schema, path, data);\n  // TODO: 有些情况会出现没有rules，需要看一下，先兜底\n\n  var validator;\n\n  try {\n    validator = new Validator(descriptor);\n  } catch (error) {\n    return Promise.resolve();\n  }\n\n  var messageFeed = locale === 'en' ? en : cn;\n  merge(messageFeed, validateMessages);\n  validator.messages(messageFeed);\n  return validator.validate(_defineProperty({}, path, data)).then(function (res) {\n    return [{\n      field: path,\n      message: null\n    }];\n  }).catch(function (_ref3) {\n    var errors = _ref3.errors,\n        fields = _ref3.fields;\n    return errors;\n  });\n};","map":null,"metadata":{},"sourceType":"module"}