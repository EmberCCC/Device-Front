{"ast":null,"code":"var _excluded = [\"style\", \"context\"],\n    _excluded2 = [\"width\"],\n    _excluded3 = [\"children\", \"ctx\"],\n    _excluded4 = [\"context\"];\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/*\nThe MIT License (MIT)\n\r\nCopyright (c) 2019 https://github.com/wubostc/\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n*/\n\n\nimport React, { useRef, useState, useCallback, useContext, useEffect, useMemo, useImperativeHandle } from \"react\";\n/**\n * THE EVENTS OF SCROLLING.\n */\n\nvar SCROLLEVT_NULL = 0 << 0;\nvar SCROLLEVT_INIT = 1 << 0;\nvar SCROLLEVT_RECOMPUTE = 1 << 1;\nvar SCROLLEVT_NATIVE = 1 << 3;\nvar SCROLLEVT_BY_HOOK = 1 << 6; // any events will be `SCROLLEVT_BY_HOOK` if the `ctx.f_top ===  TOP_CONTINUE`.\n\nvar TOP_CONTINUE = 0;\nvar TOP_DONE = 1;\n/**\n * `INIT` -> `LOADED` -> `RUNNING`\n */\n\nvar e_VT_STATE;\n\n(function (e_VT_STATE) {\n  e_VT_STATE[e_VT_STATE[\"INIT\"] = 1] = \"INIT\";\n  e_VT_STATE[e_VT_STATE[\"LOADED\"] = 2] = \"LOADED\";\n  e_VT_STATE[e_VT_STATE[\"RUNNING\"] = 4] = \"RUNNING\";\n})(e_VT_STATE || (e_VT_STATE = {}));\n\nvar row_idx = typeof Symbol === 'function' ? Symbol.for('idx') : '$$idx';\n\nfunction default_context() {\n  return {\n    vt_state: e_VT_STATE.INIT,\n    possible_hight_per_tr: -1,\n    computed_h: 0,\n    re_computed: 0,\n    row_height: [],\n    row_count: 0,\n    prev_row_count: 0,\n    _offset_top: 0 | 0,\n    _offset_head: 0 | 0,\n    _offset_tail: 0 | 1,\n    WH: 0,\n    top: 0,\n    left: 0,\n    evt: SCROLLEVT_NULL,\n    end: false,\n    final_top: 0,\n    f_final_top: TOP_DONE,\n    update_count: 0\n  };\n}\n/* overload __DIAGNOSIS__. */\n\n\nfunction helper_diagnosis(ctx) {\n  if (ctx.hasOwnProperty(\"CLICK~__DIAGNOSIS__\")) return;\n  Object.defineProperty(ctx, \"CLICK~__DIAGNOSIS__\", {\n    get: function get() {\n      console.debug(\"OoOoOoO DIAGNOSIS OoOoOoO\");\n      var expect_height = 0;\n\n      for (var i = 0; i < ctx.row_count; ++i) {\n        expect_height += ctx.row_height[i];\n      }\n\n      var color, explain;\n\n      if (expect_height > ctx.computed_h) {\n        color = \"color:rgb(15, 179, 9)\"; // green\n\n        explain = \"lower than expected\";\n      } else if (expect_height < ctx.computed_h) {\n        color = \"color:rgb(202, 61, 81)\"; // red\n\n        explain = \"higher than expected\";\n      } else {\n        color = \"color:rgba(0, 0, 0, 0.85)\";\n        explain = \"normal\";\n      }\n\n      console.debug(\"%c%d(%d)(\".concat(explain, \")\"), color, expect_height, ctx.computed_h - expect_height);\n      console.debug(\"OoOoOoOoOoOoOOoOoOoOoOoOo\");\n    },\n    configurable: false,\n    enumerable: false\n  });\n}\n\nfunction log_debug(ctx, msg) {\n  if (ctx.debug) {\n    var ts = new Date().getTime();\n    console.debug(\"%c[\".concat(ctx.id, \"][\").concat(ts, \"][\").concat(msg, \"] vt\"), \"color:#a00\", ctx);\n  }\n} // the factory function returns a SimEvent.\n\n\nfunction make_evt(ne) {\n  var target = ne.target;\n  return {\n    target: {\n      scrollTop: target.scrollTop,\n      scrollLeft: target.scrollLeft\n    },\n    end: target.scrollHeight - target.clientHeight === Math.round(target.scrollTop),\n    flag: SCROLLEVT_NATIVE\n  };\n}\n/**\n * Default Implementation Layer.\n */\n\n/** AntD.TableComponent.table */\n\n\nvar TableImpl = /*#__PURE__*/React.forwardRef(function TableImpl(props, ref) {\n  return /*#__PURE__*/React.createElement(\"table\", _objectSpread({\n    ref: ref\n  }, props));\n});\n/** AntD.TableComponent.body.wrapper */\n\nfunction WrapperImpl(props) {\n  return /*#__PURE__*/React.createElement(\"tbody\", _objectSpread({}, props));\n}\n/** AntD.TableComponent.body.row */\n\n\nvar RowImpl = /*#__PURE__*/React.forwardRef(function RowImpl(props, ref) {\n  return /*#__PURE__*/React.createElement(\"tr\", _objectSpread({\n    ref: ref\n  }, props));\n});\n/**\n * O(n)\n * returns offset: [head, tail, top]\n */\n\nfunction scroll_with_offset(ctx, top) {\n  var _ctx$scroll;\n\n  var row_height = ctx.row_height,\n      row_count = ctx.row_count,\n      overscanRowCount = ctx.overscanRowCount;\n  var scroll_y = (_ctx$scroll = ctx.scroll) === null || _ctx$scroll === void 0 ? void 0 : _ctx$scroll.y;\n\n  if (typeof scroll_y === \"number\") {\n    ctx._raw_y = scroll_y;\n    ctx._y = ctx._raw_y;\n  } else if (typeof scroll_y === \"string\") {\n    /* a string, like \"calc(100vh - 300px)\" */\n    ctx._raw_y = scroll_y;\n    ctx._y = ctx.wrap_inst.current.parentElement.offsetHeight;\n  } else {\n    console.warn(\"VT: did you forget to set `scroll.y`?\");\n    ctx._raw_y = null;\n    ctx._y = ctx.wrap_inst.current.parentElement.offsetHeight;\n  }\n\n  console.assert(ctx._y >= 0); // to calc `_top` with `row_height` and `overscan`.\n\n  var _top = 0,\n      i = 0,\n      j = 0; // the height to render.\n\n  var torender_h = 0; // scroll to the bottom of the table.\n\n  if (top === -1 && row_count > 0) {\n    i = row_count;\n\n    while (i > 0 && torender_h < ctx._y) {\n      torender_h += row_height[--i];\n    }\n\n    return [0 | i, 0 | row_count, 0 | ctx.computed_h - torender_h];\n  }\n\n  for (; i < row_count && _top < top; ++i) {\n    _top += row_height[i];\n  } // start j from the visible area\n\n\n  j = i;\n\n  for (; j < row_count && torender_h < ctx._y; ++j) {\n    torender_h += row_height[j];\n  } // keep offset row on top and bottom\n\n\n  var overscan = overscanRowCount < 0 ? 0 : overscanRowCount;\n\n  while (i > 0 && overscan--) {\n    _top -= row_height[--i];\n  }\n\n  j += overscanRowCount;\n  if (j > row_count) j = row_count; // returns [head, tail, top].\n\n  return [0 | i, 0 | j, 0 | _top];\n} // set the variables for offset top/head/tail.\n\n\nfunction set_offset(ctx, top, head, tail) {\n  ctx._offset_top = 0 | top;\n  ctx._offset_head = 0 | head;\n  ctx._offset_tail = 0 | tail;\n}\n\nfunction set_scroll(ctx, top, left, evt, end) {\n  ctx.top = top;\n  ctx.left = left;\n  ctx.evt = evt;\n  ctx.end = end;\n}\n\nfunction update_wrap_style(ctx, h) {\n  if (ctx.WH === h) return;\n  ctx.WH = h;\n  var s = ctx.wrap_inst.current.style;\n  s.height = h ? (s.maxHeight = h + 'px', s.maxHeight) : (s.maxHeight = 'unset', s.maxHeight);\n} // scrolls the parent element to specified location.\n\n\nfunction scroll_to(ctx, top, left) {\n  if (!ctx.wrap_inst.current) return;\n  var ele = ctx.wrap_inst.current.parentElement;\n  /** ie */\n\n  ele.scrollTop = top;\n  ele.scrollLeft = left;\n}\n\nfunction _repainting(ctx, ms) {\n  var fn = function fn() {\n    log_debug(ctx, \"REPAINTING\");\n\n    if (ctx.vt_state === e_VT_STATE.RUNNING && ctx.wrap_inst.current) {\n      // output to the buffer\n      update_wrap_style(ctx, ctx.computed_h);\n    } // free this handle manually.\n\n\n    ctx.HND_PAINT = 0;\n  };\n\n  return ms < 0 ? window.requestAnimationFrame(fn) : window.setTimeout(fn, ms);\n} // a wrapper function for `_repainting`.\n\n\nfunction repainting(ctx) {\n  if (ctx.HND_PAINT > 0) return;\n  ctx.HND_PAINT = _repainting(ctx, -1);\n}\n\nfunction srs_expand(ctx, len, prev_len, fill_value) {\n  var slen = len - prev_len;\n  var shadow_rows = new Array(slen).fill(fill_value);\n  ctx.row_height = ctx.row_height.concat(shadow_rows);\n  ctx.computed_h += slen * fill_value;\n}\n\nfunction srs_shrink(ctx, len, prev_len) {\n  if (len === 0) {\n    ctx.computed_h = 0;\n    ctx.row_height.length = 0;\n    return;\n  }\n\n  var rows = ctx.row_height;\n  var h2shrink = 0;\n\n  for (var i = len; i < prev_len; ++i) {\n    h2shrink += rows[i];\n  }\n\n  ctx.computed_h -= h2shrink;\n}\n\nfunction set_tr_cnt(ctx, n) {\n  ctx.re_computed = n - ctx.row_count;\n  ctx.prev_row_count = ctx.row_count;\n  ctx.row_count = n;\n}\n\nfunction VTable(props, ref) {\n  var style = props.style,\n      context = props.context,\n      rest = _objectWithoutProperties(props, _excluded); // force update this vt.\n\n\n  var force = useState(0);\n  var ref_func = useRef();\n  /*********** DOM ************/\n\n  var wrap_inst = useMemo(function () {\n    return /*#__PURE__*/React.createRef();\n  }, []);\n  /*********** context ************/\n\n  var ctx = useContext(context);\n  useMemo(function () {\n    Object.assign(ctx, default_context());\n\n    if (ctx.wrap_inst && ctx.wrap_inst.current) {\n      ctx.wrap_inst.current.parentElement.onscroll = null;\n    }\n\n    ctx.wrap_inst = wrap_inst;\n    ctx.top = ctx.initTop;\n    helper_diagnosis(ctx);\n  }, []);\n  /*********** scroll event ************/\n\n  var event_queue = useRef([]).current;\n  var HND_RAF = useRef(0); // handle of requestAnimationFrame\n\n  /* eslint-disable prefer-const */\n\n  var RAF_update_self;\n  /*********** scroll hook ************/\n\n  var scroll_hook = useCallback(function (e) {\n    if (ctx.vt_state !== e_VT_STATE.RUNNING) return;\n\n    if (e) {\n      event_queue.push(e);\n\n      if (ctx.f_final_top === TOP_CONTINUE) {\n        e.flag = SCROLLEVT_BY_HOOK;\n        return RAF_update_self(0);\n      }\n    }\n\n    if (event_queue.length) {\n      if (HND_RAF.current) cancelAnimationFrame(HND_RAF.current); // requestAnimationFrame, ie >= 10\n\n      HND_RAF.current = requestAnimationFrame(RAF_update_self);\n    }\n  }, []);\n  var scroll_hook_native = useCallback(function (e) {\n    scroll_hook(make_evt(e));\n  }, []);\n  /* requestAnimationFrame callback */\n\n  RAF_update_self = useCallback(function (_) {\n    if (ctx.vt_state !== e_VT_STATE.RUNNING) return;\n    var evq = event_queue;\n    var e; // consume the `evq` first.\n\n    if (evq.length) {\n      e = evq.shift();\n    } else {\n      return;\n    }\n\n    var etop = e.target.scrollTop;\n    var eleft = e.target.scrollLeft;\n    var flag = e.flag;\n\n    if (ctx.debug) {\n      console.debug(\"[\".concat(ctx.id, \"][SCROLL] top: %d, left: %d\"), etop, eleft);\n    } // checks every tr's height, which will take some time...\n\n\n    var offset = scroll_with_offset(ctx, ctx.f_final_top === TOP_CONTINUE ? ctx.final_top : etop);\n    var head = offset[0];\n    var tail = offset[1];\n    var top = offset[2];\n    var prev_head = ctx._offset_head;\n    var prev_tail = ctx._offset_tail;\n    var prev_top = ctx._offset_top;\n    var end;\n\n    switch (flag) {\n      case SCROLLEVT_INIT:\n        log_debug(ctx, \"SCROLLEVT_INIT\");\n        end = false;\n        break;\n\n      case SCROLLEVT_BY_HOOK:\n        log_debug(ctx, \"SCROLLEVT_BY_HOOK\");\n\n        if (head === prev_head && tail === prev_tail && top === prev_top) {\n          ctx.f_final_top = TOP_DONE;\n          if (ctx.final_top === -1) etop = ctx.computed_h - ctx._y;\n          end = true;\n        } else {\n          if (ctx.final_top === -1) etop = top;\n          end = false;\n        }\n\n        break;\n\n      case SCROLLEVT_RECOMPUTE:\n        log_debug(ctx, \"SCROLLEVT_RECOMPUTE\");\n\n        if (head === prev_head && tail === prev_tail && top === prev_top) {\n          HND_RAF.current = 0;\n          if (event_queue.length) scroll_hook(null); // consume the next.\n\n          return;\n        }\n\n        end = false;\n        break;\n\n      case SCROLLEVT_NATIVE:\n        log_debug(ctx, \"SCROLLEVT_NATIVE\");\n        HND_RAF.current = 0;\n\n        if (ctx.onScroll) {\n          ctx.onScroll({\n            top: etop,\n            left: eleft,\n            isEnd: e.end\n          });\n        }\n\n        if (head === prev_head && tail === prev_tail && top === prev_top) {\n          return;\n        }\n\n        end = e.end;\n        break;\n    }\n\n    set_offset(ctx, top, head, tail);\n    set_scroll(ctx, etop, eleft, flag, end);\n    force[1](++ctx.update_count);\n  }, []); // expose to the parent components you are using.\n\n  useImperativeHandle(ref, function () {\n    // `y === -1` indicates you need to scroll to the bottom of the table.\n    var _scrollTo = function scrollTo(y) {\n      ctx.f_final_top = TOP_CONTINUE;\n      ctx.final_top = y;\n      scroll_hook({\n        target: {\n          scrollTop: y,\n          scrollLeft: -1\n        },\n        flag: SCROLLEVT_BY_HOOK\n      });\n    };\n\n    return {\n      scrollTo: function scrollTo(y) {\n        ref_func.current = function () {\n          return _scrollTo(y);\n        };\n\n        ref_func.current();\n      },\n      scrollToIndex: function scrollToIndex(idx) {\n        ref_func.current = function () {\n          if (idx > ctx.row_count - 1) idx = ctx.row_count - 1;\n          if (idx < 0) idx = 0;\n          var y = 0;\n\n          for (var i = 0; i < idx; ++i) {\n            y += ctx.row_height[i];\n          }\n\n          _scrollTo(y);\n        };\n\n        ref_func.current();\n      }\n    };\n  }, []);\n  useEffect(function () {\n    ctx.wrap_inst.current.parentElement.onscroll = scroll_hook_native;\n  }, [wrap_inst]); // update DOM style.\n\n  useEffect(function () {\n    switch (ctx.evt) {\n      case SCROLLEVT_BY_HOOK:\n        if (ctx.f_final_top === TOP_CONTINUE) {\n          ref_func.current();\n        } else {\n          scroll_to(ctx, ctx.top, ctx.left);\n        }\n\n        break;\n\n      case SCROLLEVT_INIT:\n      case SCROLLEVT_RECOMPUTE:\n        scroll_to(ctx, ctx.top, ctx.left);\n        if (event_queue.length) RAF_update_self(0); // consume the next.\n\n        break;\n    }\n  }, [force[0]\n  /* for performance. */\n  ]);\n  useEffect(function () {\n    switch (ctx.vt_state) {\n      case e_VT_STATE.INIT:\n        // init vt without the rows.\n        break;\n\n      case e_VT_STATE.LOADED:\n        // changed by VTRow only.\n        ctx.vt_state = e_VT_STATE.RUNNING; // force update.\n\n        scroll_hook({\n          target: {\n            scrollTop: ctx.top,\n            scrollLeft: 0\n          },\n          flag: SCROLLEVT_INIT\n        });\n        break;\n\n      case e_VT_STATE.RUNNING:\n        if (ctx.re_computed !== 0) {\n          // rerender\n          ctx.re_computed = 0;\n          scroll_hook({\n            target: {\n              scrollTop: ctx.top,\n              scrollLeft: ctx.left\n            },\n            flag: SCROLLEVT_RECOMPUTE\n          });\n        }\n\n        break;\n    }\n  });\n  style.position = \"relative\";\n  style.top = ctx._offset_top;\n\n  var width = style.width,\n      rest_style = _objectWithoutProperties(style, _excluded2);\n\n  var wrap_style = useMemo(function () {\n    return {\n      width: width,\n      minWidth: \"100%\",\n      position: \"relative\",\n      transform: \"matrix(1, 0, 0, 1, 0, 0)\"\n    };\n  }, [width]);\n  var Table = ctx.components.table;\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: wrap_inst,\n    style: wrap_style\n  }, /*#__PURE__*/React.createElement(context.Provider, {\n    value: _objectSpread({}, ctx)\n  }, /*#__PURE__*/React.createElement(Table, _objectSpread(_objectSpread({}, rest), {}, {\n    style: rest_style\n  }))));\n}\n\nfunction VWrapper(props) {\n  var c = props.children,\n      ctx = props.ctx,\n      restProps = _objectWithoutProperties(props, _excluded3);\n\n  var measureRow = c[0];\n  var rows = c[1];\n  var Wrapper = ctx.components.body.wrapper; // reference https://github.com/react-component/table/blob/master/src/Body/index.tsx#L6\n\n  var len = Array.isArray(rows) ? rows.length : 0;\n  var head = ctx._offset_head,\n      tail = ctx._offset_tail;\n  var trs;\n\n  switch (ctx.vt_state) {\n    case e_VT_STATE.INIT:\n      if (len >= 0) {\n        console.assert(head === 0);\n        console.assert(tail === 1);\n\n        if (Array.isArray(rows)) {\n          trs = rows.slice(head, tail);\n          trs[0].props.record[row_idx] = 0;\n        } else {\n          trs = rows;\n        }\n\n        ctx.re_computed = len;\n        ctx.prev_row_count = len;\n        ctx.row_count = len;\n      }\n\n      break;\n\n    case e_VT_STATE.RUNNING:\n      {\n        if (tail > len) {\n          var offset = tail - len;\n          tail -= offset;\n          head -= offset;\n          if (head < 0) head = 0;\n          if (tail < 0) tail = 0; // update the `head` and `tail`.\n\n          set_offset(ctx, ctx._offset_top\n          /* NOTE: invalided param, just to fill for this param */\n          , head, tail);\n        }\n\n        if (ctx.row_count !== len) {\n          set_tr_cnt(ctx, len);\n        }\n\n        len = ctx.row_count;\n        var prev_len = ctx.prev_row_count;\n        /* shadow-rows rendering phase. */\n\n        if (len < prev_len) {\n          srs_shrink(ctx, len, prev_len);\n        } else if (len > prev_len) {\n          var row_h = ctx.row_height;\n\n          if (len - row_h.length > 0) {\n            srs_expand(ctx, len, row_h.length, ctx.possible_hight_per_tr);\n          } else {\n            // calculate the total height quickly.\n            row_h.fill(ctx.possible_hight_per_tr, prev_len, len);\n            ctx.computed_h += ctx.possible_hight_per_tr * (len - prev_len);\n          }\n        }\n        /**\n         * tree-structure if indent is not 0\n         *        |  idx\n         *        |   0   || 0a                                 0  || 0a\n         *        |   1   || 0b     --collapse occurred--       1  || 0b\n         *        |   2   || - 1                             5->2  || 0c\n         *  head  |   3   || - 1                             6->3  || 0d\n         *        |   4   ||   - 2                           7->4  || 0e\n         *        |   5   || 0c                              8->5  || - 1\n         *        |   6   || 0d                              9->6  ||   - 2\n         *        |   7   || 0e                             10->7  ||     - 3\n         *  tail  |   8   || - 1                            11->8  || 0f\n         *        |   9   ||  - 2\n         *        |  10   ||    - 3\n         *        |  11   || 0f\n         *        |  12   ||\n         */\n\n\n        if (len) {\n          var idx = head;\n          trs = rows.slice(idx, tail);\n          trs.forEach(function (el) {\n            return el.props.record[row_idx] = idx++;\n          });\n        } else {\n          trs = rows;\n        }\n\n        ctx.prev_row_count = ctx.row_count;\n      }\n      break;\n\n    case e_VT_STATE.LOADED:\n      console.assert(false);\n      break;\n  }\n\n  return /*#__PURE__*/React.createElement(Wrapper, _objectSpread({}, restProps), measureRow, trs);\n}\n\nfunction VTRow(props) {\n  var inst = /*#__PURE__*/React.createRef();\n\n  var context = props.context,\n      rest = _objectWithoutProperties(props, _excluded4);\n\n  var ctx = context;\n  var children = props.children;\n  var Row = ctx.components.body.row;\n\n  if (!Array.isArray(children)) {\n    // https://github.com/react-component/table/blob/master/src/Body/BodyRow.tsx#L211\n    // https://github.com/react-component/table/blob/master/src/Body/index.tsx#L105\n    // only empty or expanded row...\n    return /*#__PURE__*/React.createElement(Row, _objectSpread({}, rest), children);\n  }\n\n  var row_props = children[0].props;\n  var index = row_props.record[row_idx];\n  var last_index = useRef(index);\n  var expanded_cls = useMemo(function () {\n    return \".\".concat(row_props.prefixCls, \"-expanded-row\");\n  }, [row_props.prefixCls]);\n  useEffect(function () {\n    if (ctx.vt_state === e_VT_STATE.RUNNING) {\n      // apply_h(ctx, index, inst.current.offsetHeight, \"dom\");\n      repainting(ctx);\n    } else {\n      console.assert(ctx.vt_state === e_VT_STATE.INIT);\n      ctx.vt_state = e_VT_STATE.LOADED;\n      ctx.possible_hight_per_tr = inst.current.offsetHeight;\n      srs_expand(ctx, ctx.row_count, 0, ctx.possible_hight_per_tr); // create a timeout task.\n\n      _repainting(ctx, 16);\n    }\n\n    return function () {\n      return repainting(ctx);\n    };\n  }, []);\n  useEffect(function () {\n    var rowElm = inst.current; // for nested(expanded) elements don't calculate height and add on cache as its already accommodated on parent row\n    // if (!rowElm.matches(\".ant-table-row-level-0\")) return;\n\n    var h = rowElm.offsetHeight;\n    var sibling = rowElm.nextSibling; // https://github.com/react-component/table/blob/master/src/Body/BodyRow.tsx#L212\n    // include heights of all expanded rows, in parent rows\n\n    while (sibling && sibling.matches(expanded_cls)) {\n      h += sibling.offsetHeight;\n      sibling = sibling.nextSibling;\n    }\n\n    var curr_h = ctx.row_height[index];\n    var last_h = ctx.row_height[last_index.current];\n    ctx.computed_h -= curr_h;\n    ctx.computed_h += last_h;\n    ctx.computed_h += h - last_h;\n    ctx.row_height[index] = h;\n    repainting(ctx);\n  });\n  return /*#__PURE__*/React.createElement(Row, _objectSpread(_objectSpread({}, rest), {}, {\n    ref: inst\n  }));\n}\n\nexport function _set_components(ctx, components) {\n  var table = components.table,\n      body = components.body,\n      header = components.header;\n  ctx.components.body = _objectSpread(_objectSpread({}, ctx.components.body), body);\n\n  if (body && body.cell) {\n    ctx._vtcomponents.body.cell = body.cell;\n  }\n\n  if (header) {\n    ctx.components.header = header;\n    ctx._vtcomponents.header = header;\n  }\n\n  if (table) {\n    ctx.components.table = table;\n  }\n}\nexport function init(fnOpts, deps) {\n  var ctx = useRef( /*#__PURE__*/React.createContext({})).current;\n  var ctx_value = useContext(ctx);\n  var default_ref = useRef();\n  useMemo(function () {\n    return Object.assign(ctx_value, {\n      id: +new Date(),\n      initTop: 0,\n      overscanRowCount: 5,\n      debug: false,\n      ref: default_ref\n    }, fnOpts());\n  }, deps);\n  useMemo(function () {\n    var VTable2 = /*#__PURE__*/React.forwardRef(VTable); // set the virtual layer.\n\n    ctx_value._vtcomponents = {\n      table: function table(props) {\n        return /*#__PURE__*/React.createElement(VTable2, _objectSpread(_objectSpread({}, props), {}, {\n          context: ctx,\n          ref: ctx_value.ref\n        }));\n      },\n      body: {\n        wrapper: function wrapper(props) {\n          return /*#__PURE__*/React.createElement(ctx.Consumer, null, function\n            /* value */\n          () {\n            return /*#__PURE__*/React.createElement(VWrapper, _objectSpread(_objectSpread({}, props), {}, {\n              ctx: ctx_value\n            }));\n          });\n        },\n        row: function row(props) {\n          return /*#__PURE__*/React.createElement(VTRow, _objectSpread(_objectSpread({}, props), {}, {\n            context: ctx_value\n          }));\n        }\n      }\n    }; // set the default implementation layer.\n\n    ctx_value.components = {};\n\n    _set_components(ctx_value, {\n      table: TableImpl,\n      body: {\n        wrapper: WrapperImpl,\n        row: RowImpl\n      }\n    }); // start -> `INIT`\n\n\n    ctx_value.vt_state = e_VT_STATE.INIT;\n  }, []);\n  return ctx_value;\n}","map":null,"metadata":{},"sourceType":"module"}