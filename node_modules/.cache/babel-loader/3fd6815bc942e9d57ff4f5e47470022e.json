{"ast":null,"code":"import G6 from '@antv/g6';\nexport { default as G6 } from '@antv/g6';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport merge from 'lodash/merge';\nimport isArray from 'lodash/isArray';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport React from 'react';\nimport pick from 'lodash/pick';\nimport cloneDeep from 'lodash/cloneDeep';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport omit from 'lodash/omit';\nimport isPlainObject from 'lodash/isPlainObject';\nimport ReactDOM from 'react-dom';\nimport delay from 'lodash/delay';\nvar FLOW_CONTAINER_ID = 'J_FlowContainer';\nvar MIND_CONTAINER_ID = 'J_MindContainer';\nvar LABEL_DEFAULT_TEXT = '新建节点';\nvar RendererType;\n\n(function (RendererType) {\n  RendererType[\"Canvas\"] = \"canvas\";\n  RendererType[\"Svg\"] = \"svg\";\n})(RendererType || (RendererType = {}));\n\nvar ItemType;\n\n(function (ItemType) {\n  ItemType[\"Node\"] = \"node\";\n  ItemType[\"Edge\"] = \"edge\";\n})(ItemType || (ItemType = {}));\n\nvar ItemState;\n\n(function (ItemState) {\n  ItemState[\"Active\"] = \"active\";\n  ItemState[\"ActiveAnchorPoints\"] = \"activeAnchorPoints\";\n  ItemState[\"Selected\"] = \"selected\";\n  ItemState[\"HighLight\"] = \"highLight\";\n  ItemState[\"Error\"] = \"error\";\n})(ItemState || (ItemState = {}));\n\nvar GraphType;\n\n(function (GraphType) {\n  GraphType[\"Flow\"] = \"flow\";\n  GraphType[\"Mind\"] = \"mind\";\n})(GraphType || (GraphType = {}));\n\nvar GraphMode;\n\n(function (GraphMode) {\n  GraphMode[\"Default\"] = \"default\";\n  GraphMode[\"AddNode\"] = \"addNode\";\n  GraphMode[\"Readonly\"] = \"readonly\";\n})(GraphMode || (GraphMode = {}));\n\nvar GraphState;\n\n(function (GraphState) {\n  GraphState[\"NodeSelected\"] = \"nodeSelected\";\n  GraphState[\"EdgeSelected\"] = \"edgeSelected\";\n  GraphState[\"MultiSelected\"] = \"multiSelected\";\n  GraphState[\"CanvasSelected\"] = \"canvasSelected\";\n})(GraphState || (GraphState = {}));\n\nvar LabelState;\n\n(function (LabelState) {\n  LabelState[\"Hide\"] = \"hide\";\n  LabelState[\"Show\"] = \"show\";\n})(LabelState || (LabelState = {}));\n\nvar AnchorPointState;\n\n(function (AnchorPointState) {\n  AnchorPointState[\"Enabled\"] = \"enabled\";\n  AnchorPointState[\"Disabled\"] = \"disabled\";\n})(AnchorPointState || (AnchorPointState = {}));\n\nvar EditorEvent;\n\n(function (EditorEvent) {\n  /** 调用命令之前触发 */\n  EditorEvent[\"onBeforeExecuteCommand\"] = \"onBeforeExecuteCommand\";\n  /** 调用命令之后触发 */\n\n  EditorEvent[\"onAfterExecuteCommand\"] = \"onAfterExecuteCommand\";\n  /** 改变画面状态触发 */\n\n  EditorEvent[\"onGraphStateChange\"] = \"onGraphStateChange\";\n  /** 改变标签状态触发 */\n\n  EditorEvent[\"onLabelStateChange\"] = \"onLabelStateChange\";\n})(EditorEvent || (EditorEvent = {}));\n\nvar EditorCommand;\n\n(function (EditorCommand) {\n  /** 撤销 */\n  EditorCommand[\"Undo\"] = \"undo\";\n  /** 重做 */\n\n  EditorCommand[\"Redo\"] = \"redo\";\n  /** 添加 */\n\n  EditorCommand[\"Add\"] = \"add\";\n  /** 更新 */\n\n  EditorCommand[\"Update\"] = \"update\";\n  /** 删除 */\n\n  EditorCommand[\"Remove\"] = \"remove\";\n  /** 复制 */\n\n  EditorCommand[\"Copy\"] = \"copy\";\n  /** 粘贴 */\n\n  EditorCommand[\"Paste\"] = \"paste\";\n  /** 粘贴到这里 */\n\n  EditorCommand[\"PasteHere\"] = \"pasteHere\";\n  /** 放大 */\n\n  EditorCommand[\"ZoomIn\"] = \"zoomIn\";\n  /** 缩小 */\n\n  EditorCommand[\"ZoomOut\"] = \"zoomOut\";\n  /** 插入主题 */\n\n  EditorCommand[\"Topic\"] = \"topic\";\n  /** 插入子主题 */\n\n  EditorCommand[\"Subtopic\"] = \"subtopic\";\n  /** 收起 */\n\n  EditorCommand[\"Fold\"] = \"fold\";\n  /** 展开 */\n\n  EditorCommand[\"Unfold\"] = \"unfold\";\n})(EditorCommand || (EditorCommand = {}));\n\nvar GraphCommonEvent;\n\n(function (GraphCommonEvent) {\n  /** 单击鼠标左键或者按下回车键时触发 */\n  GraphCommonEvent[\"onClick\"] = \"click\";\n  /** 双击鼠标左键时触发 */\n\n  GraphCommonEvent[\"onDoubleClick\"] = \"dblclick\";\n  /** 鼠标移入元素范围内触发，该事件不冒泡，即鼠标移到其后代元素上时不会触发 */\n\n  GraphCommonEvent[\"onMouseEnter\"] = \"mouseenter\";\n  /** 鼠标在元素内部移到时不断触发，不能通过键盘触发 */\n\n  GraphCommonEvent[\"onMouseMove\"] = \"mousemove\";\n  /** 鼠标移出目标元素后触发 */\n\n  GraphCommonEvent[\"onMouseOut\"] = \"mouseout\";\n  /** 鼠标移入目标元素上方，鼠标移到其后代元素上时会触发 */\n\n  GraphCommonEvent[\"onMouseOver\"] = \"mouseover\";\n  /** 鼠标移出元素范围时触发，该事件不冒泡，即鼠标移到其后代元素时不会触发 */\n\n  GraphCommonEvent[\"onMouseLeave\"] = \"mouseleave\";\n  /** 鼠标按钮被按下（左键或者右键）时触发，不能通过键盘触发 */\n\n  GraphCommonEvent[\"onMouseDown\"] = \"mousedown\";\n  /** 鼠标按钮被释放弹起时触发，不能通过键盘触发 */\n\n  GraphCommonEvent[\"onMouseUp\"] = \"mouseup\";\n  /** 用户右击鼠标时触发并打开上下文菜单 */\n\n  GraphCommonEvent[\"onContextMenu\"] = \"contextmenu\";\n  /** 当拖拽元素开始被拖拽的时候触发的事件，此事件作用在被拖曳元素上 */\n\n  GraphCommonEvent[\"onDragStart\"] = \"dragstart\";\n  /** 当拖拽元素在拖动过程中时触发的事件，此事件作用于被拖拽元素上 */\n\n  GraphCommonEvent[\"onDrag\"] = \"drag\";\n  /** 当拖拽完成后触发的事件，此事件作用在被拖曳元素上 */\n\n  GraphCommonEvent[\"onDragEnd\"] = \"dragend\";\n  /** 当拖曳元素进入目标元素的时候触发的事件，此事件作用在目标元素上 */\n\n  GraphCommonEvent[\"onDragEnter\"] = \"dragenter\";\n  /** 当拖曳元素离开目标元素的时候触发的事件，此事件作用在目标元素上 */\n\n  GraphCommonEvent[\"onDragLeave\"] = \"dragleave\";\n  /** 被拖拽的元素在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 */\n\n  GraphCommonEvent[\"onDrop\"] = \"drop\";\n  /** 按下键盘键触发该事件 */\n\n  GraphCommonEvent[\"onKeyDown\"] = \"keydown\";\n  /** 释放键盘键触发该事件 */\n\n  GraphCommonEvent[\"onKeyUp\"] = \"keyup\";\n  /** 当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发 */\n\n  GraphCommonEvent[\"onTouchStart\"] = \"touchstart\";\n  /** 当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用 preventDefault() 事件可以阻止滚动。 */\n\n  GraphCommonEvent[\"onTouchMove\"] = \"touchmove\";\n  /** 当手指从屏幕上离开的时候触发 */\n\n  GraphCommonEvent[\"onTouchEnd\"] = \"touchend\";\n})(GraphCommonEvent || (GraphCommonEvent = {}));\n\nvar GraphNodeEvent;\n\n(function (GraphNodeEvent) {\n  /** 鼠标左键单击节点时触发 */\n  GraphNodeEvent[\"onNodeClick\"] = \"node:click\";\n  /** 鼠标双击左键节点时触发 */\n\n  GraphNodeEvent[\"onNodeDoubleClick\"] = \"node:dblclick\";\n  /** 鼠标移入节点时触发 */\n\n  GraphNodeEvent[\"onNodeMouseEnter\"] = \"node:mouseenter\";\n  /** 鼠标在节点内部移到时不断触发，不能通过键盘触发 */\n\n  GraphNodeEvent[\"onNodeMouseMove\"] = \"node:mousemove\";\n  /** 鼠标移出节点后触发 */\n\n  GraphNodeEvent[\"onNodeMouseOut\"] = \"node:mouseout\";\n  /** 鼠标移入节点上方时触发 */\n\n  GraphNodeEvent[\"onNodeMouseOver\"] = \"node:mouseover\";\n  /** 鼠标移出节点时触发 */\n\n  GraphNodeEvent[\"onNodeMouseLeave\"] = \"node:mouseleave\";\n  /** 鼠标按钮在节点上按下（左键或者右键）时触发，不能通过键盘触发 */\n\n  GraphNodeEvent[\"onNodeMouseDown\"] = \"node:mousedown\";\n  /** 节点上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */\n\n  GraphNodeEvent[\"onNodeMouseUp\"] = \"node:mouseup\";\n  /** 用户在节点上右击鼠标时触发并打开右键菜单 */\n\n  GraphNodeEvent[\"onNodeContextMenu\"] = \"node:contextmenu\";\n  /** 当节点开始被拖拽的时候触发的事件，此事件作用在被拖曳节点上 */\n\n  GraphNodeEvent[\"onNodeDragStart\"] = \"node:dragstart\";\n  /** 当节点在拖动过程中时触发的事件，此事件作用于被拖拽节点上 */\n\n  GraphNodeEvent[\"onNodeDrag\"] = \"node:drag\";\n  /** 当拖拽完成后触发的事件，此事件作用在被拖曳节点上 */\n\n  GraphNodeEvent[\"onNodeDragEnd\"] = \"node:dragend\";\n  /** 当拖曳节点进入目标元素的时候触发的事件，此事件作用在目标元素上 */\n\n  GraphNodeEvent[\"onNodeDragEnter\"] = \"node:dragenter\";\n  /** 当拖曳节点离开目标元素的时候触发的事件，此事件作用在目标元素上 */\n\n  GraphNodeEvent[\"onNodeDragLeave\"] = \"node:dragleave\";\n  /** 被拖拽的节点在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 */\n\n  GraphNodeEvent[\"onNodeDrop\"] = \"node:drop\";\n})(GraphNodeEvent || (GraphNodeEvent = {}));\n\nvar GraphEdgeEvent;\n\n(function (GraphEdgeEvent) {\n  /** 鼠标左键单击边时触发 */\n  GraphEdgeEvent[\"onEdgeClick\"] = \"edge:click\";\n  /** 鼠标双击左键边时触发 */\n\n  GraphEdgeEvent[\"onEdgeDoubleClick\"] = \"edge:dblclick\";\n  /** 鼠标移入边时触发 */\n\n  GraphEdgeEvent[\"onEdgeMouseEnter\"] = \"edge:mouseenter\";\n  /** 鼠标在边上移到时不断触发，不能通过键盘触发 */\n\n  GraphEdgeEvent[\"onEdgeMouseMove\"] = \"edge:mousemove\";\n  /** 鼠标移出边后触发 */\n\n  GraphEdgeEvent[\"onEdgeMouseOut\"] = \"edge:mouseout\";\n  /** 鼠标移入边上方时触发 */\n\n  GraphEdgeEvent[\"onEdgeMouseOver\"] = \"edge:mouseover\";\n  /** 鼠标移出边时触发 */\n\n  GraphEdgeEvent[\"onEdgeMouseLeave\"] = \"edge:mouseleave\";\n  /** 鼠标按钮在边上按下（左键或者右键）时触发，不能通过键盘触发 */\n\n  GraphEdgeEvent[\"onEdgeMouseDown\"] = \"edge:mousedown\";\n  /** 边上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */\n\n  GraphEdgeEvent[\"onEdgeMouseUp\"] = \"edge:mouseup\";\n  /** 用户在边上右击鼠标时触发并打开右键菜单 */\n\n  GraphEdgeEvent[\"onEdgeContextMenu\"] = \"edge:contextmenu\";\n})(GraphEdgeEvent || (GraphEdgeEvent = {}));\n\nvar GraphCanvasEvent;\n\n(function (GraphCanvasEvent) {\n  /** 鼠标左键单击画布时触发 */\n  GraphCanvasEvent[\"onCanvasClick\"] = \"canvas:click\";\n  /** 鼠标双击左键画布时触发 */\n\n  GraphCanvasEvent[\"onCanvasDoubleClick\"] = \"canvas:dblclick\";\n  /** 鼠标移入画布时触发 */\n\n  GraphCanvasEvent[\"onCanvasMouseEnter\"] = \"canvas:mouseenter\";\n  /** 鼠标在画布内部移到时不断触发，不能通过键盘触发 */\n\n  GraphCanvasEvent[\"onCanvasMouseMove\"] = \"canvas:mousemove\";\n  /** 鼠标移出画布后触发 */\n\n  GraphCanvasEvent[\"onCanvasMouseOut\"] = \"canvas:mouseout\";\n  /** 鼠标移入画布上方时触发 */\n\n  GraphCanvasEvent[\"onCanvasMouseOver\"] = \"canvas:mouseover\";\n  /** 鼠标移出画布时触发 */\n\n  GraphCanvasEvent[\"onCanvasMouseLeave\"] = \"canvas:mouseleave\";\n  /** 鼠标按钮在画布上按下（左键或者右键）时触发，不能通过键盘触发 */\n\n  GraphCanvasEvent[\"onCanvasMouseDown\"] = \"canvas:mousedown\";\n  /** 画布上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */\n\n  GraphCanvasEvent[\"onCanvasMouseUp\"] = \"canvas:mouseup\";\n  /** 用户在画布上右击鼠标时触发并打开右键菜单 */\n\n  GraphCanvasEvent[\"onCanvasContextMenu\"] = \"canvas:contextmenu\";\n  /** 当画布开始被拖拽的时候触发的事件，此事件作用在被拖曳画布上 */\n\n  GraphCanvasEvent[\"onCanvasDragStart\"] = \"canvas:dragstart\";\n  /** 当画布在拖动过程中时触发的事件，此事件作用于被拖拽画布上 */\n\n  GraphCanvasEvent[\"onCanvasDrag\"] = \"canvas:drag\";\n  /** 当拖拽完成后触发的事件，此事件作用在被拖曳画布上 */\n\n  GraphCanvasEvent[\"onCanvasDragEnd\"] = \"canvas:dragend\";\n  /** 当拖曳画布进入目标元素的时候触发的事件，此事件作用在目标元素上 */\n\n  GraphCanvasEvent[\"onCanvasDragEnter\"] = \"canvas:dragenter\";\n  /** 当拖曳画布离开目标元素的时候触发的事件，此事件作用在目标元素上 */\n\n  GraphCanvasEvent[\"onCanvasDragLeave\"] = \"canvas:dragleave\";\n})(GraphCanvasEvent || (GraphCanvasEvent = {}));\n\nvar GraphCustomEvent;\n\n(function (GraphCustomEvent) {\n  /** 调用 add / addItem 方法之前触发 */\n  GraphCustomEvent[\"onBeforeAddItem\"] = \"beforeadditem\";\n  /** 调用 add / addItem 方法之后触发 */\n\n  GraphCustomEvent[\"onAfterAddItem\"] = \"afteradditem\";\n  /** 调用 remove / removeItem 方法之前触发 */\n\n  GraphCustomEvent[\"onBeforeRemoveItem\"] = \"beforeremoveitem\";\n  /** 调用 remove / removeItem 方法之后触发 */\n\n  GraphCustomEvent[\"onAfterRemoveItem\"] = \"afterremoveitem\";\n  /** 调用 update / updateItem 方法之前触发 */\n\n  GraphCustomEvent[\"onBeforeUpdateItem\"] = \"beforeupdateitem\";\n  /** 调用 update / updateItem 方法之后触发 */\n\n  GraphCustomEvent[\"onAfterUpdateItem\"] = \"afterupdateitem\";\n  /** 调用 showItem / hideItem 方法之前触发 */\n\n  GraphCustomEvent[\"onBeforeItemVisibilityChange\"] = \"beforeitemvisibilitychange\";\n  /** 调用 showItem / hideItem 方法之后触发 */\n\n  GraphCustomEvent[\"onAfterItemVisibilityChange\"] = \"afteritemvisibilitychange\";\n  /** 调用 setItemState 方法之前触发 */\n\n  GraphCustomEvent[\"onBeforeItemStateChange\"] = \"beforeitemstatechange\";\n  /** 调用 setItemState 方法之后触发 */\n\n  GraphCustomEvent[\"onAfterItemStateChange\"] = \"afteritemstatechange\";\n  /** 调用 refreshItem 方法之前触发 */\n\n  GraphCustomEvent[\"onBeforeRefreshItem\"] = \"beforerefreshitem\";\n  /** 调用 refreshItem 方法之后触发 */\n\n  GraphCustomEvent[\"onAfterRefreshItem\"] = \"afterrefreshitem\";\n  /** 调用 clearItemStates 方法之前触发 */\n\n  GraphCustomEvent[\"onBeforeItemStatesClear\"] = \"beforeitemstatesclear\";\n  /** 调用 clearItemStates 方法之后触发 */\n\n  GraphCustomEvent[\"onAfterItemStatesClear\"] = \"afteritemstatesclear\";\n  /** 布局前触发。调用 render 时会进行布局，因此 render 时会触发。或用户主动调用图的 layout 时触发 */\n\n  GraphCustomEvent[\"onBeforeLayout\"] = \"beforelayout\";\n  /** 布局完成后触发。调用 render 时会进行布局，因此 render 时布局完成后会触发。或用户主动调用图的 layout 时布局完成后触发 */\n\n  GraphCustomEvent[\"onAfterLayout\"] = \"afterlayout\";\n  /** 连线完成之后触发 */\n\n  GraphCustomEvent[\"onAfterConnect\"] = \"afterconnect\";\n})(GraphCustomEvent || (GraphCustomEvent = {}));\n\nvar index =\n/*#__PURE__*/\nObject.freeze({\n  __proto__: null,\n  FLOW_CONTAINER_ID: FLOW_CONTAINER_ID,\n  MIND_CONTAINER_ID: MIND_CONTAINER_ID,\n  LABEL_DEFAULT_TEXT: LABEL_DEFAULT_TEXT,\n\n  get RendererType() {\n    return RendererType;\n  },\n\n  get ItemType() {\n    return ItemType;\n  },\n\n  get ItemState() {\n    return ItemState;\n  },\n\n  get GraphType() {\n    return GraphType;\n  },\n\n  get GraphMode() {\n    return GraphMode;\n  },\n\n  get GraphState() {\n    return GraphState;\n  },\n\n  get LabelState() {\n    return LabelState;\n  },\n\n  get AnchorPointState() {\n    return AnchorPointState;\n  },\n\n  get EditorEvent() {\n    return EditorEvent;\n  },\n\n  get EditorCommand() {\n    return EditorCommand;\n  },\n\n  get GraphCommonEvent() {\n    return GraphCommonEvent;\n  },\n\n  get GraphNodeEvent() {\n    return GraphNodeEvent;\n  },\n\n  get GraphEdgeEvent() {\n    return GraphEdgeEvent;\n  },\n\n  get GraphCanvasEvent() {\n    return GraphCanvasEvent;\n  },\n\n  get GraphCustomEvent() {\n    return GraphCustomEvent;\n  }\n\n});\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar canvas = document.createElement('canvas');\nvar canvasContext = canvas.getContext('2d');\n\nfunction getNodeSide(item) {\n  var model = item.getModel();\n\n  if (model.side) {\n    return model.side;\n  }\n\n  var parent = item.get('parent');\n\n  if (parent) {\n    return getNodeSide(parent);\n  }\n\n  return 'right';\n}\n\nfunction getRectPath(x, y, w, h, r) {\n  if (r) {\n    return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];\n  }\n\n  var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];\n  res.toString = toString;\n  return res;\n}\n\nfunction getFoldButtonPath() {\n  var w = 14;\n  var h = 14;\n  var rect = getRectPath(0, 0, w, h, 2);\n  var hp = \"M\" + w * 3 / 14 + \",\" + h / 2 + \"L\" + w * 11 / 14 + \",\" + h / 2;\n  var vp = '';\n  return rect + hp + vp;\n}\n\nfunction getUnfoldButtonPath() {\n  var w = 14;\n  var h = 14;\n  var rect = getRectPath(0, 0, w, h, 2);\n  var hp = \"M\" + w * 3 / 14 + \",\" + h / 2 + \"L\" + w * 11 / 14 + \",\" + h / 2;\n  var vp = \"M\" + w / 2 + \",\" + h * 3 / 14 + \"L\" + w / 2 + \",\" + h * 11 / 14;\n  return rect + hp + vp;\n}\n\nfunction optimizeMultilineText(text, font, maxRows, maxWidth) {\n  canvasContext.font = font;\n\n  if (canvasContext.measureText(text).width <= maxWidth) {\n    return text;\n  }\n\n  var multilineText = [];\n  var tempText = '';\n  var tempTextWidth = 0;\n\n  for (var _iterator = _createForOfIteratorHelperLoose(text), _step; !(_step = _iterator()).done;) {\n    var _char2 = _step.value;\n\n    var _canvasContext$measur2 = canvasContext.measureText(_char2),\n        _width = _canvasContext$measur2.width;\n\n    if (tempTextWidth + _width >= maxWidth) {\n      multilineText.push(tempText);\n      tempText = '';\n      tempTextWidth = 0;\n    }\n\n    tempText += _char2;\n    tempTextWidth += _width;\n  }\n\n  if (tempText) {\n    multilineText.push(tempText);\n  }\n\n  if (multilineText.length > maxRows) {\n    var ellipsis = '...';\n    var ellipsisWidth = canvasContext.measureText(ellipsis).width;\n    var _tempText = '';\n    var _tempTextWidth = 0;\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(multilineText[maxRows - 1]), _step2; !(_step2 = _iterator2()).done;) {\n      var _char = _step2.value;\n\n      var _canvasContext$measur = canvasContext.measureText(_char),\n          width = _canvasContext$measur.width;\n\n      if (_tempTextWidth + width > maxWidth - ellipsisWidth) {\n        break;\n      }\n\n      _tempText += _char;\n      _tempTextWidth += width;\n    }\n\n    multilineText = multilineText.slice(0, maxRows - 1).concat(\"\" + _tempText + ellipsis);\n  }\n\n  return multilineText.join('\\n');\n}\n\nvar _stateStyles;\n\nvar WRAPPER_BORDER_WIDTH = 2;\nvar WRAPPER_HORIZONTAL_PADDING = 10;\nvar WRAPPER_CLASS_NAME = 'node-wrapper';\nvar CONTENT_CLASS_NAME = 'node-content';\nvar LABEL_CLASS_NAME = 'node-label';\nvar bizNode = {\n  options: {\n    size: [120, 60],\n    wrapperStyle: {\n      fill: '#5487ea',\n      radius: 8\n    },\n    contentStyle: {\n      fill: '#ffffff',\n      radius: 6\n    },\n    labelStyle: {\n      fill: '#000000',\n      textAlign: 'center',\n      textBaseline: 'middle'\n    },\n    stateStyles: (_stateStyles = {}, _stateStyles[ItemState.Active] = {\n      wrapperStyle: {},\n      contentStyle: {},\n      labelStyle: {}\n    }, _stateStyles[ItemState.Selected] = {\n      wrapperStyle: {},\n      contentStyle: {},\n      labelStyle: {}\n    }, _stateStyles)\n  },\n  getOptions: function getOptions(model) {\n    return merge({}, this.options, this.getCustomConfig(model) || {}, model);\n  },\n  draw: function draw(model, group) {\n    var keyShape = this.drawWrapper(model, group);\n    this.drawContent(model, group);\n    this.drawLabel(model, group);\n    return keyShape;\n  },\n  drawWrapper: function drawWrapper(model, group) {\n    var _this$getSize = this.getSize(model),\n        width = _this$getSize[0],\n        height = _this$getSize[1];\n\n    var _this$getOptions = this.getOptions(model),\n        wrapperStyle = _this$getOptions.wrapperStyle;\n\n    var shape = group.addShape('rect', {\n      className: WRAPPER_CLASS_NAME,\n      draggable: true,\n      attrs: _extends({\n        x: 0,\n        y: -WRAPPER_BORDER_WIDTH * 2,\n        width: width,\n        height: height + WRAPPER_BORDER_WIDTH * 2\n      }, wrapperStyle)\n    });\n    return shape;\n  },\n  drawContent: function drawContent(model, group) {\n    var _this$getSize2 = this.getSize(model),\n        width = _this$getSize2[0],\n        height = _this$getSize2[1];\n\n    var _this$getOptions2 = this.getOptions(model),\n        contentStyle = _this$getOptions2.contentStyle;\n\n    var shape = group.addShape('rect', {\n      className: CONTENT_CLASS_NAME,\n      draggable: true,\n      attrs: _extends({\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      }, contentStyle)\n    });\n    return shape;\n  },\n  drawLabel: function drawLabel(model, group) {\n    var _this$getSize3 = this.getSize(model),\n        width = _this$getSize3[0],\n        height = _this$getSize3[1];\n\n    var _this$getOptions3 = this.getOptions(model),\n        labelStyle = _this$getOptions3.labelStyle;\n\n    var shape = group.addShape('text', {\n      className: LABEL_CLASS_NAME,\n      draggable: true,\n      attrs: _extends({\n        x: width / 2,\n        y: height / 2,\n        text: model.label\n      }, labelStyle)\n    });\n    return shape;\n  },\n  setLabelText: function setLabelText(model, group) {\n    var shape = group.findByClassName(LABEL_CLASS_NAME);\n\n    if (!shape) {\n      return;\n    }\n\n    var _this$getSize4 = this.getSize(model),\n        width = _this$getSize4[0];\n\n    var _shape$attr = shape.attr(),\n        fontStyle = _shape$attr.fontStyle,\n        fontWeight = _shape$attr.fontWeight,\n        fontSize = _shape$attr.fontSize,\n        fontFamily = _shape$attr.fontFamily;\n\n    var text = model.label;\n    var font = fontStyle + \" \" + fontWeight + \" \" + fontSize + \"px \" + fontFamily;\n    shape.attr('text', optimizeMultilineText(text, font, 2, width - WRAPPER_HORIZONTAL_PADDING * 2));\n  },\n  update: function update(model, item) {\n    var group = item.getContainer();\n    this.setLabelText(model, group);\n  },\n  setState: function setState(name, value, item) {\n    var _this = this;\n\n    var group = item.getContainer();\n    var model = item.getModel();\n    var states = item.getStates();\n    [WRAPPER_CLASS_NAME, CONTENT_CLASS_NAME, LABEL_CLASS_NAME].forEach(function (className) {\n      var shape = group.findByClassName(className);\n\n      var options = _this.getOptions(model);\n\n      var shapeName = className.split('-')[1];\n      shape.attr(_extends({}, options[shapeName + \"Style\"]));\n      states.forEach(function (state) {\n        if (options.stateStyles[state] && options.stateStyles[state][shapeName + \"Style\"]) {\n          shape.attr(_extends({}, options.stateStyles[state][shapeName + \"Style\"]));\n        }\n      });\n    });\n\n    if (name === ItemState.Selected) {\n      var wrapperShape = group.findByClassName(WRAPPER_CLASS_NAME);\n\n      var _this$getSize5 = this.getSize(model),\n          width = _this$getSize5[0],\n          height = _this$getSize5[1];\n\n      if (value) {\n        wrapperShape.attr({\n          x: -WRAPPER_BORDER_WIDTH,\n          y: -WRAPPER_BORDER_WIDTH * 2,\n          width: width + WRAPPER_BORDER_WIDTH * 2,\n          height: height + WRAPPER_BORDER_WIDTH * 3\n        });\n      } else {\n        wrapperShape.attr({\n          x: 0,\n          y: -WRAPPER_BORDER_WIDTH * 2,\n          width: width,\n          height: height + WRAPPER_BORDER_WIDTH * 2\n        });\n      }\n    }\n\n    if (this.afterSetState) {\n      this.afterSetState(name, value, item);\n    }\n  },\n  getSize: function getSize(model) {\n    var _this$getOptions4 = this.getOptions(model),\n        size = _this$getOptions4.size;\n\n    if (!isArray(size)) {\n      return [size, size];\n    }\n\n    return size;\n  },\n  getCustomConfig: function getCustomConfig() {\n    return {};\n  },\n  getAnchorPoints: function getAnchorPoints() {\n    return [];\n  }\n};\nG6.registerNode('bizNode', bizNode);\nvar ANCHOR_POINT_NAME = 'anchorPoint';\n\nvar getAnchorPointDefaultStyle = function getAnchorPointDefaultStyle(item, anchorPoint) {\n  var _item$getKeyShape$get = item.getKeyShape().getBBox(),\n      width = _item$getKeyShape$get.width,\n      height = _item$getKeyShape$get.height;\n\n  var x = anchorPoint[0],\n      y = anchorPoint[1];\n  return {\n    x: width * x,\n    y: height * y - 3,\n    r: 3,\n    lineWidth: 2,\n    fill: '#FFFFFF',\n    stroke: '#5AAAFF'\n  };\n};\n\nvar getAnchorPointDefaultDisabledStyle = function getAnchorPointDefaultDisabledStyle(item, anchorPoint) {\n  var _item$getKeyShape$get2 = item.getKeyShape().getBBox(),\n      width = _item$getKeyShape$get2.width,\n      height = _item$getKeyShape$get2.height;\n\n  var x = anchorPoint[0],\n      y = anchorPoint[1];\n  return {\n    img: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOSIgaGVpZ2h0PSI4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0xLjUxNSAxLjE3Mmw1LjY1NyA1LjY1Nm0wLTUuNjU2TDEuNTE1IDYuODI4IiBzdHJva2U9IiNGRjYwNjAiIHN0cm9rZS13aWR0aD0iMS42IiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIi8+PC9zdmc+',\n    x: width * x - 4,\n    y: height * y - 8,\n    width: 8,\n    height: 8\n  };\n};\n\nfunction drawAnchorPoints(item, getAnchorPointStyle, getAnchorPointDisabledStyle) {\n  var group = item.getContainer();\n  var model = item.getModel();\n  var anchorPoints = this.getAnchorPoints ? this.getAnchorPoints(model) : [];\n  var anchorPointsState = item.get('anchorPointsState') || [];\n  anchorPoints.forEach(function (anchorPoint, index) {\n    if (anchorPointsState[index] === AnchorPointState.Enabled) {\n      group.addShape('circle', {\n        name: ANCHOR_POINT_NAME,\n        attrs: _extends({}, getAnchorPointDefaultStyle(item, anchorPoint), getAnchorPointStyle(item, anchorPoint)),\n        isAnchorPoint: true,\n        anchorPointIndex: index,\n        anchorPointState: AnchorPointState.Enabled\n      });\n    } else {\n      group.addShape('image', {\n        name: ANCHOR_POINT_NAME,\n        attrs: _extends({}, getAnchorPointDefaultDisabledStyle(item, anchorPoint), getAnchorPointDisabledStyle(item, anchorPoint)),\n        isAnchorPoint: true,\n        anchorPointIndex: index,\n        anchorPointState: AnchorPointState.Disabled\n      });\n    }\n  });\n}\n\nfunction removeAnchorPoints(item) {\n  var group = item.getContainer();\n  var anchorPoints = group.findAllByName(ANCHOR_POINT_NAME);\n  anchorPoints.forEach(function (anchorPoint) {\n    group.removeChild(anchorPoint);\n  });\n}\n\nfunction setAnchorPointsState(name, value, item, getAnchorPointStyle, getAnchorPointDisabledStyle) {\n  if (getAnchorPointStyle === void 0) {\n    getAnchorPointStyle = function getAnchorPointStyle() {\n      return {};\n    };\n  }\n\n  if (getAnchorPointDisabledStyle === void 0) {\n    getAnchorPointDisabledStyle = function getAnchorPointDisabledStyle() {\n      return {};\n    };\n  }\n\n  if (name !== ItemState.ActiveAnchorPoints) {\n    return;\n  }\n\n  if (value) {\n    drawAnchorPoints.call(this, item, getAnchorPointStyle, getAnchorPointDisabledStyle);\n  } else {\n    removeAnchorPoints.call(this, item);\n  }\n}\n\nvar bizFlowNode = {\n  afterSetState: function afterSetState(name, value, item) {\n    setAnchorPointsState.call(this, name, value, item);\n  },\n  getAnchorPoints: function getAnchorPoints() {\n    return [[0.5, 0], [0.5, 1], [0, 0.5], [1, 0.5]];\n  }\n};\nG6.registerNode('bizFlowNode', bizFlowNode, 'bizNode');\nvar FOLD_BUTTON_CLASS_NAME = 'node-fold-button';\nvar UNFOLD_BUTTON_CLASS_NAME = 'node-unfold-button';\nvar bizMindNode = {\n  afterDraw: function afterDraw(model, group) {\n    this.drawButton(model, group);\n  },\n  afterUpdate: function afterUpdate(model, item) {\n    var group = item.getContainer();\n    this.drawButton(model, group);\n    this.adjustButton(model, item);\n  },\n  drawButton: function drawButton(model, group) {\n    var children = model.children,\n        collapsed = model.collapsed;\n    [FOLD_BUTTON_CLASS_NAME, UNFOLD_BUTTON_CLASS_NAME].forEach(function (className) {\n      var shape = group.findByClassName(className);\n\n      if (shape) {\n        shape.destroy();\n      }\n    });\n\n    if (!children || !children.length) {\n      return;\n    }\n\n    if (!collapsed) {\n      group.addShape('path', {\n        className: FOLD_BUTTON_CLASS_NAME,\n        attrs: {\n          path: getFoldButtonPath(),\n          fill: '#ffffff',\n          stroke: '#ccc1d8'\n        }\n      });\n    } else {\n      group.addShape('path', {\n        className: UNFOLD_BUTTON_CLASS_NAME,\n        attrs: {\n          path: getUnfoldButtonPath(),\n          fill: '#ffffff',\n          stroke: '#ccc1d8'\n        }\n      });\n    }\n  },\n  adjustButton: function adjustButton(model, item) {\n    var children = model.children,\n        collapsed = model.collapsed;\n\n    if (!children || !children.length) {\n      return;\n    }\n\n    var group = item.getContainer();\n    var shape = group.findByClassName(!collapsed ? FOLD_BUTTON_CLASS_NAME : UNFOLD_BUTTON_CLASS_NAME);\n\n    var _this$getSize = this.getSize(model),\n        width = _this$getSize[0],\n        height = _this$getSize[1];\n\n    var x = getNodeSide(item) === 'left' ? -24 : width + 10;\n    var y = height / 2 - 9;\n    shape.translate(x, y);\n  },\n  getAnchorPoints: function getAnchorPoints() {\n    return [[0, 0.5], [1, 0.5]];\n  }\n};\nG6.registerNode('bizMindNode', bizMindNode, 'bizNode');\n\nvar _stateStyles$1;\n\nvar EDGE_LABEL_CLASS_NAME = 'edge-label';\nvar EDGE_LABEL_WRAPPER_CLASS_NAME = 'edge-label-wrapper-label';\nvar bizFlowEdge = {\n  options: {\n    style: {\n      stroke: '#ccc1d8',\n      lineWidth: 2,\n      shadowColor: null,\n      shadowBlur: 0,\n      radius: 8,\n      offset: 24,\n      // startArrow: {\n      //   path: 'M 3,0 A 3,3,0,1,1,-3,0 A 3,3,0,1,1,3,0 Z',\n      //   d: 7,\n      // },\n      // endArrow: {\n      //   path: 'M 3,0 L -3,-3 L -3,3 Z',\n      //   d: 5,\n      // },\n      endArrow: {\n        path: 'M 0,0 L 4,3 L 4,-3 Z'\n      }\n    },\n    labelCfg: {\n      style: {\n        fill: '#000000',\n        fontSize: 10\n      }\n    },\n    stateStyles: (_stateStyles$1 = {}, _stateStyles$1[ItemState.Selected] = {\n      stroke: '#5aaaff',\n      shadowColor: '#5aaaff',\n      shadowBlur: 24\n    }, _stateStyles$1[ItemState.HighLight] = {\n      stroke: '#5aaaff',\n      shadowColor: '#5aaaff',\n      shadowBlur: 24\n    }, _stateStyles$1)\n  },\n  createLabelWrapper: function createLabelWrapper(group) {\n    var label = group.findByClassName(EDGE_LABEL_CLASS_NAME);\n    var labelWrapper = group.findByClassName(EDGE_LABEL_WRAPPER_CLASS_NAME);\n\n    if (!label) {\n      return;\n    }\n\n    if (labelWrapper) {\n      return;\n    }\n\n    group.addShape('rect', {\n      className: EDGE_LABEL_WRAPPER_CLASS_NAME,\n      attrs: {\n        fill: '#e1e5e8',\n        radius: 2\n      }\n    });\n    label.set('zIndex', 1);\n    group.sort();\n  },\n  updateLabelWrapper: function updateLabelWrapper(group) {\n    var label = group.findByClassName(EDGE_LABEL_CLASS_NAME);\n    var labelWrapper = group.findByClassName(EDGE_LABEL_WRAPPER_CLASS_NAME);\n\n    if (!label) {\n      labelWrapper && labelWrapper.hide();\n      return;\n    } else {\n      labelWrapper && labelWrapper.show();\n    }\n\n    if (!labelWrapper) {\n      return;\n    }\n\n    var _label$getBBox = label.getBBox(),\n        minX = _label$getBBox.minX,\n        minY = _label$getBBox.minY,\n        width = _label$getBBox.width,\n        height = _label$getBBox.height;\n\n    labelWrapper.attr({\n      x: minX - 5,\n      y: minY - 3,\n      width: width + 10,\n      height: height + 6\n    });\n  },\n  afterDraw: function afterDraw(model, group) {\n    this.createLabelWrapper(group);\n    this.updateLabelWrapper(group);\n  },\n  afterUpdate: function afterUpdate(model, item) {\n    var group = item.getContainer();\n    this.createLabelWrapper(group);\n    this.updateLabelWrapper(group);\n  },\n  setState: function setState(name, value, item) {\n    var shape = item.get('keyShape');\n\n    if (!shape) {\n      return;\n    }\n\n    var _this$options = this.options,\n        style = _this$options.style,\n        stateStyles = _this$options.stateStyles;\n    var stateStyle = stateStyles[name];\n\n    if (!stateStyle) {\n      return;\n    }\n\n    if (value) {\n      shape.attr(_extends({}, style, stateStyle));\n    } else {\n      shape.attr(style);\n    }\n  }\n};\nG6.registerEdge('bizFlowEdge', bizFlowEdge, 'polyline');\n\nvar _stateStyles$2;\n\nvar bizMindEdge = {\n  options: {\n    style: {\n      stroke: '#ccc1d8',\n      lineWidth: 2,\n      shadowColor: null,\n      shadowBlur: 0\n    },\n    stateStyles: (_stateStyles$2 = {}, _stateStyles$2[ItemState.Selected] = {\n      stroke: '#5aaaff',\n      shadowColor: '#5aaaff',\n      shadowBlur: 24\n    }, _stateStyles$2[ItemState.HighLight] = {\n      stroke: '#5aaaff',\n      shadowColor: '#5aaaff',\n      shadowBlur: 24\n    }, _stateStyles$2)\n  },\n  setState: function setState(name, value, item) {\n    var shape = item.get('keyShape');\n\n    if (!shape) {\n      return;\n    }\n\n    var _this$options = this.options,\n        style = _this$options.style,\n        stateStyles = _this$options.stateStyles;\n    var stateStyle = stateStyles[name];\n\n    if (!stateStyle) {\n      return;\n    }\n\n    if (value) {\n      shape.attr(_extends({}, style, stateStyle));\n    } else {\n      shape.attr(style);\n    }\n  }\n};\nG6.registerEdge('bizMindEdge', bizMindEdge, 'cubic-horizontal');\n/** 生成唯一标识 */\n\nfunction guid() {\n  return 'xxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/** 拼接查询字符 */\n\n\nvar toQueryString = function toQueryString(obj) {\n  return Object.keys(obj).map(function (key) {\n    return encodeURIComponent(key) + \"=\" + encodeURIComponent(obj[key]);\n  }).join('&');\n};\n/** 执行批量处理 */\n\n\nfunction executeBatch(graph, execute) {\n  var autoPaint = graph.get('autoPaint');\n  graph.setAutoPaint(false);\n  execute();\n  graph.paint();\n  graph.setAutoPaint(autoPaint);\n}\n/** 执行递归遍历 */\n\n\nfunction recursiveTraversal(root, callback) {\n  if (!root) {\n    return;\n  }\n\n  callback(root);\n\n  if (!root.children) {\n    return;\n  }\n\n  root.children.forEach(function (item) {\n    return recursiveTraversal(item, callback);\n  });\n}\n/** 判断是否流程图 */\n\n\nfunction isFlow(graph) {\n  return graph.constructor === G6.Graph;\n}\n/** 判断是否脑图 */\n\n\nfunction isMind(graph) {\n  return graph.constructor === G6.TreeGraph;\n}\n/** 判断是否节点 */\n\n\nfunction isNode(item) {\n  return item.getType() === ItemType.Node;\n}\n/** 判断是否边线 */\n\n\nfunction isEdge(item) {\n  return item.getType() === ItemType.Edge;\n}\n/** 获取选中节点 */\n\n\nfunction getSelectedNodes(graph) {\n  return graph.findAllByState(ItemType.Node, ItemState.Selected);\n}\n/** 获取选中边线 */\n\n\nfunction getSelectedEdges(graph) {\n  return graph.findAllByState(ItemType.Edge, ItemState.Selected);\n}\n/** 获取高亮边线 */\n\n\nfunction getHighlightEdges(graph) {\n  return graph.findAllByState(ItemType.Edge, ItemState.HighLight);\n}\n/** 获取图表状态 */\n\n\nfunction getGraphState(graph) {\n  var graphState = GraphState.MultiSelected;\n  var selectedNodes = getSelectedNodes(graph);\n  var selectedEdges = getSelectedEdges(graph);\n\n  if (selectedNodes.length === 1 && !selectedEdges.length) {\n    graphState = GraphState.NodeSelected;\n  }\n\n  if (selectedEdges.length === 1 && !selectedNodes.length) {\n    graphState = GraphState.EdgeSelected;\n  }\n\n  if (!selectedNodes.length && !selectedEdges.length) {\n    graphState = GraphState.CanvasSelected;\n  }\n\n  return graphState;\n}\n/** 设置选中元素 */\n\n\nfunction setSelectedItems(graph, items) {\n  executeBatch(graph, function () {\n    var selectedNodes = getSelectedNodes(graph);\n    var selectedEdges = getSelectedEdges(graph);\n    [].concat(selectedNodes, selectedEdges).forEach(function (node) {\n      graph.setItemState(node, ItemState.Selected, false);\n    });\n    items.forEach(function (item) {\n      graph.setItemState(item, ItemState.Selected, true);\n    });\n  });\n  graph.emit(EditorEvent.onGraphStateChange, {\n    graphState: getGraphState(graph)\n  });\n}\n/** 清除选中状态 */\n\n\nfunction clearSelectedState(graph, shouldUpdate) {\n  if (shouldUpdate === void 0) {\n    shouldUpdate = function shouldUpdate() {\n      return true;\n    };\n  }\n\n  var selectedNodes = getSelectedNodes(graph);\n  var selectedEdges = getSelectedEdges(graph);\n  executeBatch(graph, function () {\n    [].concat(selectedNodes, selectedEdges).forEach(function (item) {\n      if (shouldUpdate(item)) {\n        graph.setItemState(item, ItemState.Selected, false);\n      }\n    });\n  });\n}\n/** 获取回溯路径 - Flow */\n\n\nfunction getFlowRecallEdges(graph, node, targetIds, edges) {\n  if (targetIds === void 0) {\n    targetIds = [];\n  }\n\n  if (edges === void 0) {\n    edges = [];\n  }\n\n  var inEdges = node.getInEdges();\n\n  if (!inEdges.length) {\n    return [];\n  }\n\n  inEdges.map(function (edge) {\n    var sourceId = edge.getModel().source;\n    var sourceNode = graph.findById(sourceId);\n    edges.push(edge);\n    var targetId = node.get('id');\n    targetIds.push(targetId);\n\n    if (!targetIds.includes(sourceId)) {\n      getFlowRecallEdges(graph, sourceNode, targetIds, edges);\n    }\n  });\n  return edges;\n}\n/** 获取\b回溯路径 - Mind */\n\n\nfunction getMindRecallEdges(graph, node, edges) {\n  if (edges === void 0) {\n    edges = [];\n  }\n\n  var parentNode = node.get('parent');\n\n  if (!parentNode) {\n    return edges;\n  }\n\n  node.getEdges().forEach(function (edge) {\n    var source = edge.getModel().source;\n\n    if (source.get('id') === parentNode.get('id')) {\n      edges.push(edge);\n    }\n  });\n  return getMindRecallEdges(graph, parentNode, edges);\n}\n\nvar index$1 =\n/*#__PURE__*/\nObject.freeze({\n  __proto__: null,\n  guid: guid,\n  toQueryString: toQueryString,\n  executeBatch: executeBatch,\n  recursiveTraversal: recursiveTraversal,\n  isFlow: isFlow,\n  isMind: isMind,\n  isNode: isNode,\n  isEdge: isEdge,\n  getSelectedNodes: getSelectedNodes,\n  getSelectedEdges: getSelectedEdges,\n  getHighlightEdges: getHighlightEdges,\n  getGraphState: getGraphState,\n  setSelectedItems: setSelectedItems,\n  clearSelectedState: clearSelectedState,\n  getFlowRecallEdges: getFlowRecallEdges,\n  getMindRecallEdges: getMindRecallEdges\n});\n\nvar Global = function Global() {\n  /** 当前版本 */\n  this.version = \"3.1.3\";\n  /** 埋点开关 */\n\n  this.trackable = true;\n  /** 剪贴板 */\n\n  this.clipboard = {\n    point: {\n      x: 0,\n      y: 0\n    },\n    models: []\n  };\n  /** 组件数据 */\n\n  this.component = {\n    itemPanel: {\n      model: null,\n      delegateShapeClassName: \"delegateShape_\" + guid()\n    }\n  };\n  /** 插件数据 */\n\n  this.plugin = {\n    itemPopover: {\n      state: 'hide'\n    },\n    contextMenu: {\n      state: 'hide'\n    },\n    editableLabel: {\n      state: 'hide'\n    }\n  };\n};\n\nvar global = new Global();\n\nvar CommandManager =\n/*#__PURE__*/\nfunction () {\n  function CommandManager() {\n    this.command = {};\n    this.commandQueue = [];\n    this.commandIndex = 0;\n  }\n  /** 注册命令 */\n\n\n  var _proto = CommandManager.prototype;\n\n  _proto.register = function register(name, command) {\n    this.command[name] = _extends({}, command, {\n      name: name\n    });\n  }\n  /** 执行命令 */\n  ;\n\n  _proto.execute = function execute(graph, name, params) {\n    var Command = this.command[name];\n\n    if (!Command) {\n      return;\n    }\n\n    var command = Object.create(Command);\n    command.params = cloneDeep(Command.params);\n\n    if (params) {\n      command.params = _extends({}, command.params, params);\n    }\n\n    if (!command.canExecute(graph)) {\n      return;\n    }\n\n    if (!command.shouldExecute(graph)) {\n      return;\n    }\n\n    command.init(graph);\n    graph.emit(EditorEvent.onBeforeExecuteCommand, {\n      name: command.name,\n      params: command.params\n    });\n    command.execute(graph);\n    graph.emit(EditorEvent.onAfterExecuteCommand, {\n      name: command.name,\n      params: command.params\n    });\n\n    if (command.canUndo(graph)) {\n      var commandQueue = this.commandQueue,\n          commandIndex = this.commandIndex;\n      commandQueue.splice(commandIndex, commandQueue.length - commandIndex, command);\n      this.commandIndex += 1;\n    }\n\n    graph.emit(EditorEvent.onGraphStateChange, {\n      graphState: getGraphState(graph)\n    });\n  }\n  /** 判断是否可以执行 */\n  ;\n\n  _proto.canExecute = function canExecute(graph, name) {\n    return this.command[name].canExecute(graph);\n  }\n  /** 注入是否应该执行 */\n  ;\n\n  _proto.injectShouldExecute = function injectShouldExecute(name, shouldExecute) {\n    this.command[name].shouldExecute = shouldExecute;\n  };\n\n  return CommandManager;\n}();\n\nfunction withContext(Context, shouldRender) {\n  if (shouldRender === void 0) {\n    shouldRender = function shouldRender() {\n      return true;\n    };\n  }\n\n  return function (WrappedComponent) {\n    var InjectContext = function InjectContext(props) {\n      var forwardRef = props.forwardRef,\n          rest = _objectWithoutPropertiesLoose(props, [\"forwardRef\"]);\n\n      var refProp = {};\n\n      if (WrappedComponent.prototype.isReactComponent) {\n        refProp = {\n          ref: forwardRef\n        };\n      } else {\n        refProp = {\n          forwardRef: forwardRef\n        };\n      }\n\n      return (\n        /*#__PURE__*/\n        React.createElement(Context.Consumer, null, function (context) {\n          return shouldRender(context) ?\n          /*#__PURE__*/\n          React.createElement(WrappedComponent, Object.assign({}, refProp, rest, context)) : null;\n        })\n      );\n    };\n\n    return (\n      /*#__PURE__*/\n      React.forwardRef(function (props, ref) {\n        return (\n          /*#__PURE__*/\n          React.createElement(InjectContext, Object.assign({\n            forwardRef: ref\n          }, props))\n        );\n      })\n    );\n  };\n}\n\nvar EditorContext =\n/*#__PURE__*/\nReact.createContext({});\nvar EditorPrivateContext =\n/*#__PURE__*/\nReact.createContext({});\nvar withEditorContext = withContext(EditorContext, function (context) {\n  return !!context.graph;\n});\nvar withEditorPrivateContext = withContext(EditorPrivateContext);\n\nvar _Editor$defaultProps;\n\nvar Editor =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(Editor, _React$Component);\n\n  function Editor(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.lastMousedownTarget = null;\n\n    _this.setGraph = function (graph) {\n      _this.setState({\n        graph: graph\n      });\n\n      _this.bindEvent(graph);\n\n      _this.bindShortcut(graph);\n    };\n\n    _this.executeCommand = function (name, params) {\n      var _this$state = _this.state,\n          graph = _this$state.graph,\n          commandManager = _this$state.commandManager;\n\n      if (graph) {\n        commandManager.execute(graph, name, params);\n      }\n    };\n\n    _this.state = {\n      graph: null,\n      setGraph: _this.setGraph,\n      executeCommand: _this.executeCommand,\n      commandManager: new CommandManager()\n    };\n    _this.lastMousedownTarget = null;\n    return _this;\n  }\n\n  Editor.setTrackable = function setTrackable(trackable) {\n    global.trackable = trackable;\n  };\n\n  var _proto = Editor.prototype;\n\n  _proto.shouldTriggerShortcut = function shouldTriggerShortcut(graph, target) {\n    var renderer = graph.get('renderer');\n    var canvasElement = graph.get('canvas').get('el');\n\n    if (!target) {\n      return false;\n    }\n\n    if (target === canvasElement) {\n      return true;\n    }\n\n    if (renderer === RendererType.Svg) {\n      if (target.nodeName === 'svg') {\n        return true;\n      }\n\n      var parentNode = target.parentNode;\n\n      while (parentNode && parentNode.nodeName !== 'BODY') {\n        if (parentNode.nodeName === 'svg') {\n          return true;\n        } else {\n          parentNode = parentNode.parentNode;\n        }\n      }\n\n      return false;\n    }\n  };\n\n  _proto.bindEvent = function bindEvent(graph) {\n    var props = this.props;\n    graph.on(EditorEvent.onBeforeExecuteCommand, props[EditorEvent.onBeforeExecuteCommand]);\n    graph.on(EditorEvent.onAfterExecuteCommand, props[EditorEvent.onAfterExecuteCommand]);\n  };\n\n  _proto.bindShortcut = function bindShortcut(graph) {\n    var _this2 = this;\n\n    var commandManager = this.state.commandManager;\n    window.addEventListener(GraphCommonEvent.onMouseDown, function (e) {\n      _this2.lastMousedownTarget = e.target;\n    });\n    graph.on(GraphCommonEvent.onKeyDown, function (e) {\n      if (!_this2.shouldTriggerShortcut(graph, _this2.lastMousedownTarget)) {\n        return;\n      }\n\n      Object.values(commandManager.command).some(function (command) {\n        var name = command.name,\n            shortcuts = command.shortcuts;\n        var flag = shortcuts.some(function (shortcut) {\n          var key = e.key;\n\n          if (!isArray(shortcut)) {\n            return shortcut === key;\n          }\n\n          return shortcut.every(function (item, index) {\n            if (index === shortcut.length - 1) {\n              return item === key;\n            }\n\n            return e[item];\n          });\n        });\n\n        if (flag) {\n          if (commandManager.canExecute(graph, name)) {\n            // Prevent default\n            e.preventDefault(); // Execute command\n\n            _this2.executeCommand(name);\n\n            return true;\n          }\n        }\n\n        return false;\n      });\n    });\n  };\n\n  _proto.render = function render() {\n    var children = this.props.children;\n    var _this$state2 = this.state,\n        graph = _this$state2.graph,\n        setGraph = _this$state2.setGraph,\n        executeCommand = _this$state2.executeCommand,\n        commandManager = _this$state2.commandManager;\n    return (\n      /*#__PURE__*/\n      React.createElement(EditorContext.Provider, {\n        value: {\n          graph: graph,\n          executeCommand: executeCommand,\n          commandManager: commandManager\n        }\n      },\n      /*#__PURE__*/\n      React.createElement(EditorPrivateContext.Provider, {\n        value: {\n          setGraph: setGraph,\n          commandManager: commandManager\n        }\n      },\n      /*#__PURE__*/\n      React.createElement(\"div\", Object.assign({}, pick(this.props, ['className', 'style'])), children)))\n    );\n  };\n\n  return Editor;\n}(React.Component);\n\nEditor.defaultProps = (_Editor$defaultProps = {}, _Editor$defaultProps[EditorEvent.onBeforeExecuteCommand] = function () {}, _Editor$defaultProps[EditorEvent.onAfterExecuteCommand] = function () {}, _Editor$defaultProps);\n\nvar BehaviorManager =\n/*#__PURE__*/\nfunction () {\n  function BehaviorManager() {\n    this.behaviors = {};\n  }\n\n  var _proto = BehaviorManager.prototype;\n\n  _proto.getRegisteredBehaviors = function getRegisteredBehaviors(type) {\n    var _this = this;\n\n    var registeredBehaviors = {};\n    Object.keys(this.behaviors).forEach(function (name) {\n      var behavior = _this.behaviors[name];\n      var graphType = behavior.graphType;\n\n      if (graphType && graphType !== type) {\n        return;\n      }\n\n      var _behavior$graphMode = behavior.graphMode,\n          graphMode = _behavior$graphMode === void 0 ? 'default' : _behavior$graphMode;\n\n      if (!registeredBehaviors[graphMode]) {\n        registeredBehaviors[graphMode] = {};\n      }\n\n      registeredBehaviors[graphMode][name] = name;\n    });\n    return registeredBehaviors;\n  };\n\n  _proto.wrapEventHandler = function wrapEventHandler(type, behavior) {\n    var events = behavior.getEvents();\n    Object.keys(events).forEach(function (event) {\n      var handlerName = events[event];\n      var handler = behavior[handlerName];\n\n      behavior[handlerName] = function () {\n        var graph = this.graph;\n\n        if (type === GraphType.Flow && isMind(graph) === false || type === GraphType.Mind && isMind(graph)) {\n          for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n            params[_key] = arguments[_key];\n          }\n\n          handler.apply(this, params);\n        }\n      };\n    });\n    return behavior;\n  };\n\n  _proto.register = function register(name, behavior) {\n    var graphType = behavior.graphType;\n    this.behaviors[name] = behavior;\n\n    switch (graphType) {\n      case GraphType.Flow:\n        G6.registerBehavior(name, this.wrapEventHandler(GraphType.Flow, behavior));\n        break;\n\n      case GraphType.Mind:\n        G6.registerBehavior(name, this.wrapEventHandler(GraphType.Mind, behavior));\n        break;\n\n      default:\n        G6.registerBehavior(name, behavior);\n        break;\n    }\n  };\n\n  return BehaviorManager;\n}();\n\nvar behaviorManager = new BehaviorManager();\nvar BASE_URL = 'http://gm.mmstat.com/fsp.1.1';\n\nfunction track(graphType) {\n  var version = global.version;\n  var trackable = global.trackable;\n\n  if (!trackable) {\n    return;\n  }\n\n  var _window = window,\n      location = _window.location,\n      navigator = _window.navigator;\n  var image = new Image();\n  var params = toQueryString({\n    pid: 'ggeditor',\n    code: '11',\n    msg: 'syslog',\n    page: location.protocol + \"//\" + location.host + location.pathname,\n    hash: location.hash,\n    ua: navigator.userAgent,\n    rel: version,\n    c1: graphType\n  });\n  image.src = BASE_URL + \"?\" + params;\n}\n\nvar redoCommand = {\n  name: 'redo',\n  params: {},\n  canExecute: function canExecute(graph) {\n    var commandManager = graph.get('commandManager');\n    var commandQueue = commandManager.commandQueue,\n        commandIndex = commandManager.commandIndex;\n    return commandIndex < commandQueue.length;\n  },\n  shouldExecute: function shouldExecute() {\n    return true;\n  },\n  canUndo: function canUndo() {\n    return false;\n  },\n  init: function init() {},\n  execute: function execute(graph) {\n    var commandManager = graph.get('commandManager');\n    var commandQueue = commandManager.commandQueue,\n        commandIndex = commandManager.commandIndex;\n    commandQueue[commandIndex].execute(graph);\n    commandManager.commandIndex += 1;\n  },\n  undo: function undo() {},\n  shortcuts: [['metaKey', 'shiftKey', 'z'], ['ctrlKey', 'shiftKey', 'z']]\n};\nvar undoCommand = {\n  name: 'undo',\n  params: {},\n  canExecute: function canExecute(graph) {\n    var commandManager = graph.get('commandManager');\n    var commandIndex = commandManager.commandIndex;\n    return commandIndex > 0;\n  },\n  shouldExecute: function shouldExecute() {\n    return true;\n  },\n  canUndo: function canUndo() {\n    return false;\n  },\n  init: function init() {},\n  execute: function execute(graph) {\n    var commandManager = graph.get('commandManager');\n    var commandQueue = commandManager.commandQueue,\n        commandIndex = commandManager.commandIndex;\n    commandQueue[commandIndex - 1].undo(graph);\n    commandManager.commandIndex -= 1;\n  },\n  undo: function undo() {},\n  shortcuts: [['metaKey', 'z'], ['ctrlKey', 'z']]\n};\nvar baseCommand = {\n  name: '',\n  params: {},\n  canExecute: function canExecute() {\n    return true;\n  },\n  shouldExecute: function shouldExecute() {\n    return true;\n  },\n  canUndo: function canUndo() {\n    return true;\n  },\n  init: function init() {},\n  execute: function execute() {},\n  undo: function undo() {},\n  shortcuts: [],\n  isMind: isMind,\n  getSelectedNodes: getSelectedNodes,\n  getSelectedEdges: getSelectedEdges,\n  setSelectedItems: setSelectedItems,\n  editSelectedNode: function editSelectedNode(graph) {\n    graph.emit(EditorEvent.onLabelStateChange, {\n      labelState: LabelState.Show\n    });\n  }\n};\n\nvar addCommand = _extends({}, baseCommand, {\n  params: {\n    type: ItemType.Node,\n    model: {\n      id: ''\n    }\n  },\n  init: function init() {\n    var model = this.params.model;\n\n    if (model.id) {\n      return;\n    }\n\n    model.id = guid();\n  },\n  execute: function execute(graph) {\n    var _this$params = this.params,\n        type = _this$params.type,\n        model = _this$params.model;\n    graph.add(type, model);\n    this.setSelectedItems(graph, [model.id]);\n  },\n  undo: function undo(graph) {\n    var model = this.params.model;\n    graph.remove(model.id);\n  }\n});\n\nvar removeCommand = _extends({}, baseCommand, {\n  params: {\n    flow: {\n      nodes: {},\n      edges: {}\n    },\n    mind: {\n      model: null,\n      parent: ''\n    }\n  },\n  canExecute: function canExecute(graph) {\n    var selectedNodes = this.getSelectedNodes(graph);\n    var selectedEdges = this.getSelectedEdges(graph);\n    return !!(selectedNodes.length || selectedEdges.length);\n  },\n  init: function init(graph) {\n    var selectedNodes = this.getSelectedNodes(graph);\n    var selectedEdges = this.getSelectedEdges(graph);\n\n    if (isMind(graph)) {\n      var selectedNode = selectedNodes[0];\n      var selectedNodeModel = selectedNode.getModel();\n      var selectedNodeParent = selectedNode.get('parent');\n      var selectedNodeParentModel = selectedNodeParent ? selectedNodeParent.getModel() : {};\n      this.params.mind = {\n        model: selectedNodeModel,\n        parent: selectedNodeParentModel.id\n      };\n    } else {\n      var _this$params$flow = this.params.flow,\n          nodes = _this$params$flow.nodes,\n          edges = _this$params$flow.edges;\n      selectedNodes.forEach(function (node) {\n        var nodeModel = node.getModel();\n        var nodeEdges = node.getEdges();\n        nodes[nodeModel.id] = nodeModel;\n        nodeEdges.forEach(function (edge) {\n          var edgeModel = edge.getModel();\n          edges[edgeModel.id] = edgeModel;\n        });\n      });\n      selectedEdges.forEach(function (edge) {\n        var edgeModel = edge.getModel();\n        edges[edgeModel.id] = edgeModel;\n      });\n    }\n  },\n  execute: function execute(graph) {\n    if (isMind(graph)) {\n      var model = this.params.mind.model;\n\n      if (!model) {\n        return;\n      }\n\n      graph.removeChild(model.id);\n    } else {\n      var _this$params$flow2 = this.params.flow,\n          nodes = _this$params$flow2.nodes,\n          edges = _this$params$flow2.edges;\n      executeBatch(graph, function () {\n        [].concat(Object.keys(nodes), Object.keys(edges)).forEach(function (id) {\n          graph.removeItem(id);\n        });\n      });\n    }\n  },\n  undo: function undo(graph) {\n    if (isMind(graph)) {\n      var _this$params$mind = this.params.mind,\n          model = _this$params$mind.model,\n          parent = _this$params$mind.parent;\n\n      if (!model) {\n        return;\n      }\n\n      graph.addChild(model, parent);\n    } else {\n      var _this$params$flow3 = this.params.flow,\n          nodes = _this$params$flow3.nodes,\n          edges = _this$params$flow3.edges;\n      executeBatch(graph, function () {\n        Object.keys(nodes).forEach(function (id) {\n          var model = nodes[id];\n          graph.addItem(ItemType.Node, model);\n        });\n        Object.keys(edges).forEach(function (id) {\n          var model = edges[id];\n          graph.addItem(ItemType.Edge, model);\n        });\n      });\n    }\n  },\n  shortcuts: ['Delete', 'Backspace']\n});\n\nvar updateCommand = _extends({}, baseCommand, {\n  params: {\n    id: '',\n    originModel: {},\n    updateModel: {},\n    forceRefreshLayout: false\n  },\n  canExecute: function canExecute(graph) {\n    var selectedNodes = this.getSelectedNodes(graph);\n    var selectedEdges = this.getSelectedEdges(graph);\n    return (selectedNodes.length || selectedEdges.length) && (selectedNodes.length === 1 || selectedEdges.length === 1) ? true : false;\n  },\n  init: function init(graph) {\n    var _this$params = this.params,\n        id = _this$params.id,\n        updateModel = _this$params.updateModel;\n    var updatePaths = Object.keys(updateModel);\n    var originModel = pick(graph.findById(id).getModel(), updatePaths);\n    this.params.originModel = originModel;\n  },\n  execute: function execute(graph) {\n    var _this$params2 = this.params,\n        id = _this$params2.id,\n        updateModel = _this$params2.updateModel,\n        forceRefreshLayout = _this$params2.forceRefreshLayout;\n    graph.updateItem(id, updateModel);\n\n    if (forceRefreshLayout) {\n      graph.refreshLayout && graph.refreshLayout(false);\n    }\n  },\n  undo: function undo(graph) {\n    var _this$params3 = this.params,\n        id = _this$params3.id,\n        originModel = _this$params3.originModel;\n    graph.updateItem(id, originModel);\n  }\n});\n\nvar copyCommand = _extends({}, baseCommand, {\n  canExecute: function canExecute(graph) {\n    return !!this.getSelectedNodes(graph).length;\n  },\n  canUndo: function canUndo() {\n    return false;\n  },\n  execute: function execute(graph) {\n    var selectedNodes = this.getSelectedNodes(graph);\n    global.clipboard.models = cloneDeep(selectedNodes.map(function (node) {\n      return node.getModel();\n    }));\n  },\n  shortcuts: [['metaKey', 'c'], ['ctrlKey', 'c']]\n});\n\nvar pasteCommand = _extends({}, baseCommand, {\n  params: {\n    models: []\n  },\n  canExecute: function canExecute() {\n    return !!global.clipboard.models.length;\n  },\n  init: function init() {\n    var models = global.clipboard.models;\n    var offsetX = 10;\n    var offsetY = 10;\n    this.params = {\n      models: models.map(function (model) {\n        var x = model.x,\n            y = model.y;\n        return _extends({}, model, {\n          id: guid(),\n          x: x + offsetX,\n          y: y + offsetY\n        });\n      })\n    };\n  },\n  execute: function execute(graph) {\n    var models = this.params.models;\n    executeBatch(graph, function () {\n      models.forEach(function (model) {\n        graph.addItem(ItemType.Node, model);\n      });\n    });\n    this.setSelectedItems(graph, models.map(function (model) {\n      return model.id;\n    }));\n  },\n  undo: function undo(graph) {\n    var models = this.params.models;\n    executeBatch(graph, function () {\n      models.forEach(function (model) {\n        graph.removeItem(model.id);\n      });\n    });\n  },\n  shortcuts: [['metaKey', 'v'], ['ctrlKey', 'v']]\n});\n\nvar pasteHereCommand = _extends({}, pasteCommand, {\n  params: {\n    models: []\n  },\n  init: function init() {\n    var _global$clipboard = global.clipboard,\n        point = _global$clipboard.point,\n        models = _global$clipboard.models;\n    this.params = {\n      models: models.map(function (model) {\n        var x = model.x,\n            y = model.y;\n        var offsetX = point.x - x;\n        var offsetY = point.y - y;\n        return _extends({}, model, {\n          id: guid(),\n          x: x + offsetX,\n          y: y + offsetY\n        });\n      })\n    };\n  },\n  shortcuts: []\n});\n\nvar DELTA = 0.05;\n\nvar zoomInCommand = _extends({}, baseCommand, {\n  canUndo: function canUndo() {\n    return false;\n  },\n  execute: function execute(graph) {\n    var ratio = 1 + DELTA;\n    var zoom = graph.getZoom() * ratio;\n    var maxZoom = graph.get('maxZoom');\n\n    if (zoom > maxZoom) {\n      return;\n    }\n\n    graph.zoom(ratio);\n  },\n  shortcuts: [['metaKey', '='], ['ctrlKey', '=']]\n});\n\nvar DELTA$1 = 0.05;\n\nvar zoomOutCommand = _extends({}, baseCommand, {\n  canUndo: function canUndo() {\n    return false;\n  },\n  execute: function execute(graph) {\n    var ratio = 1 - DELTA$1;\n    var zoom = graph.getZoom() * ratio;\n    var minZoom = graph.get('minZoom');\n\n    if (zoom < minZoom) {\n      return;\n    }\n\n    graph.zoom(ratio);\n  },\n  shortcuts: [['metaKey', '-'], ['ctrlKey', '-']]\n});\n\nvar baseCommands = {\n  redo: redoCommand,\n  undo: undoCommand,\n  add: addCommand,\n  remove: removeCommand,\n  update: updateCommand,\n  copy: copyCommand,\n  paste: pasteCommand,\n  pasteHere: pasteHereCommand,\n  zoomIn: zoomInCommand,\n  zoomOut: zoomOutCommand\n};\n\nvar topicCommand = _extends({}, baseCommand, {\n  params: {\n    id: '',\n    model: {\n      id: ''\n    }\n  },\n  canExecute: function canExecute(graph) {\n    var selectedNodes = this.getSelectedNodes(graph);\n    return selectedNodes.length && selectedNodes.length === 1 && selectedNodes[0].get('parent');\n  },\n  init: function init(graph) {\n    if (this.params.id) {\n      return;\n    }\n\n    var selectedNode = this.getSelectedNodes(graph)[0];\n    this.params = {\n      id: selectedNode.get('id'),\n      model: {\n        id: guid(),\n        label: LABEL_DEFAULT_TEXT\n      }\n    };\n  },\n  execute: function execute(graph) {\n    var _this$params = this.params,\n        id = _this$params.id,\n        model = _this$params.model;\n    var parent = graph.findById(id).get('parent'); // 添加节点\n\n    graph.addChild(model, parent); // 选中节点\n\n    this.setSelectedItems(graph, [model.id]); // 编辑节点\n\n    this.editSelectedNode(graph);\n  },\n  undo: function undo(graph) {\n    var _this$params2 = this.params,\n        id = _this$params2.id,\n        model = _this$params2.model;\n    this.setSelectedItems(graph, [id]);\n    graph.removeChild(model.id);\n  },\n  shortcuts: ['Enter']\n});\n\nvar subtopicCommand = _extends({}, topicCommand, {\n  canExecute: function canExecute(graph) {\n    return this.getSelectedNodes(graph)[0] ? true : false;\n  },\n  execute: function execute(graph) {\n    var _this$params = this.params,\n        id = _this$params.id,\n        model = _this$params.model; // 添加节点\n\n    graph.addChild(model, id); // 选中节点\n\n    this.setSelectedItems(graph, [model.id]); // 编辑节点\n\n    this.editSelectedNode(graph);\n  },\n  shortcuts: ['Tab']\n});\n\nvar foldCommand = _extends({}, baseCommand, {\n  params: {\n    id: ''\n  },\n  canExecute: function canExecute(graph) {\n    var selectedNodes = this.getSelectedNodes(graph);\n\n    if (!selectedNodes.length) {\n      return false;\n    }\n\n    var selectedNode = selectedNodes[0];\n    var selectedNodeModel = selectedNode.getModel();\n\n    if (!selectedNodeModel.children || !selectedNodeModel.children.length) {\n      return false;\n    }\n\n    if (selectedNodeModel.collapsed) {\n      return false;\n    }\n\n    return true;\n  },\n  init: function init(graph) {\n    var selectedNode = this.getSelectedNodes(graph)[0];\n    var selectedNodeModel = selectedNode.getModel();\n    this.params = {\n      id: selectedNodeModel.id\n    };\n  },\n  execute: function execute(graph) {\n    var id = this.params.id;\n    var sourceData = graph.findDataById(id);\n    sourceData.collapsed = !sourceData.collapsed;\n    graph.refreshLayout(false);\n  },\n  undo: function undo(graph) {\n    this.execute(graph);\n  },\n  shortcuts: [['metaKey', '/'], ['ctrlKey', '/']]\n});\n\nvar unfoldCommand = _extends({}, foldCommand, {\n  canExecute: function canExecute(graph) {\n    var selectedNodes = this.getSelectedNodes(graph);\n\n    if (!selectedNodes.length) {\n      return false;\n    }\n\n    var selectedNode = selectedNodes[0];\n    var selectedNodeModel = selectedNode.getModel();\n\n    if (!selectedNodeModel.children || !selectedNodeModel.children.length) {\n      return false;\n    }\n\n    if (!selectedNodeModel.collapsed) {\n      return false;\n    }\n\n    return true;\n  },\n  shortcuts: [['metaKey', '/'], ['ctrlKey', '/']]\n});\n\nvar mindCommands = {\n  topic: topicCommand,\n  subtopic: subtopicCommand,\n  fold: foldCommand,\n  unfold: unfoldCommand\n};\nvar clickItemBehavior = {\n  getDefaultCfg: function getDefaultCfg() {\n    return {\n      multiple: true,\n      keydown: false,\n      keyCode: 17\n    };\n  },\n  getEvents: function getEvents() {\n    return {\n      'node:click': 'handleItemClick',\n      'edge:click': 'handleItemClick',\n      'canvas:click': 'handleCanvasClick',\n      keydown: 'handleKeyDown',\n      keyup: 'handleKeyUp'\n    };\n  },\n  handleItemClick: function handleItemClick(_ref) {\n    var item = _ref.item;\n    var graph = this.graph;\n\n    if (isMind(graph) && isEdge(item)) {\n      return;\n    }\n\n    var isSelected = item.hasState(ItemState.Selected);\n\n    if (this.multiple && this.keydown) {\n      graph.setItemState(item, ItemState.Selected, !isSelected);\n    } else {\n      clearSelectedState(graph, function (selectedItem) {\n        return selectedItem !== item;\n      });\n\n      if (!isSelected) {\n        graph.setItemState(item, ItemState.Selected, true);\n      }\n    }\n\n    graph.emit(EditorEvent.onGraphStateChange, {\n      graphState: getGraphState(graph)\n    });\n  },\n  handleCanvasClick: function handleCanvasClick() {\n    var graph = this.graph;\n    clearSelectedState(graph);\n    graph.emit(EditorEvent.onGraphStateChange, {\n      graphState: GraphState.CanvasSelected\n    });\n  },\n  handleKeyDown: function handleKeyDown(e) {\n    this.keydown = (e.keyCode || e.which) === this.keyCode;\n  },\n  handleKeyUp: function handleKeyUp() {\n    this.keydown = false;\n  }\n};\nbehaviorManager.register('click-item', clickItemBehavior);\nvar hoverItemBehavior = {\n  getEvents: function getEvents() {\n    return {\n      'node:mouseenter': 'handleItemMouseenter',\n      'edge:mouseenter': 'handleItemMouseenter',\n      'node:mouseleave': 'handleItemMouseleave',\n      'edge:mouseleave': 'handleItemMouseleave'\n    };\n  },\n  handleItemMouseenter: function handleItemMouseenter(_ref) {\n    var item = _ref.item;\n    var graph = this.graph;\n    graph.setItemState(item, ItemState.Active, true);\n  },\n  handleItemMouseleave: function handleItemMouseleave(_ref2) {\n    var item = _ref2.item;\n    var graph = this.graph;\n    graph.setItemState(item, ItemState.Active, false);\n  }\n};\nbehaviorManager.register('hover-item', hoverItemBehavior);\nvar dragCanvasBehavior = {\n  origin: null,\n  keyCode: null,\n  dragging: false,\n  handleWindowMouseUp: null,\n  getDefaultCfg: function getDefaultCfg() {\n    return {\n      allowKeyCode: [],\n      notAllowKeyCode: [16]\n    };\n  },\n  getEvents: function getEvents() {\n    return {\n      'canvas:dragstart': 'handleCanvasDragStart',\n      'canvas:drag': 'handleCanvasDrag',\n      'canvas:dragend': 'handleCanvasDragEnd',\n      'canvas:mouseleave': 'handleCanvasMouseLeave',\n      'canvas:contextmenu': 'handleCanvasContextMenu',\n      keydown: 'handleKeyDown',\n      keyup: 'handleKeyUp'\n    };\n  },\n  canDrag: function canDrag() {\n    var keyCode = this.keyCode,\n        allowKeyCode = this.allowKeyCode,\n        notAllowKeyCode = this.notAllowKeyCode;\n    var isAllow = !!!allowKeyCode.length;\n\n    if (!keyCode) {\n      return isAllow;\n    }\n\n    if (allowKeyCode.length && allowKeyCode.includes(keyCode)) {\n      isAllow = true;\n    }\n\n    if (notAllowKeyCode.includes(keyCode)) {\n      isAllow = false;\n    }\n\n    return isAllow;\n  },\n  updateViewport: function updateViewport(e) {\n    var clientX = e.clientX,\n        clientY = e.clientY;\n    var dx = clientX - this.origin.x;\n    var dy = clientY - this.origin.y;\n    this.origin = {\n      x: clientX,\n      y: clientY\n    };\n    this.graph.translate(dx, dy);\n    this.graph.paint();\n  },\n  handleCanvasDragStart: function handleCanvasDragStart(e) {\n    if (!this.shouldBegin.call(this, e)) {\n      return;\n    }\n\n    if (!this.canDrag()) {\n      return;\n    }\n\n    this.origin = {\n      x: e.clientX,\n      y: e.clientY\n    };\n    this.dragging = false;\n  },\n  handleCanvasDrag: function handleCanvasDrag(e) {\n    if (!this.shouldUpdate.call(this, e)) {\n      return;\n    }\n\n    if (!this.canDrag()) {\n      return;\n    }\n\n    if (!this.origin) {\n      return;\n    }\n\n    if (!this.dragging) {\n      this.dragging = true;\n    } else {\n      this.updateViewport(e);\n    }\n  },\n  handleCanvasDragEnd: function handleCanvasDragEnd(e) {\n    if (!this.shouldEnd.call(this, e)) {\n      return;\n    }\n\n    if (!this.canDrag()) {\n      return;\n    }\n\n    this.origin = null;\n    this.dragging = false;\n\n    if (this.handleWindowMouseUp) {\n      document.body.removeEventListener('mouseup', this.handleWindowMouseUp, false);\n      this.handleWindowMouseUp = null;\n    }\n  },\n  handleCanvasMouseLeave: function handleCanvasMouseLeave() {\n    var _this = this;\n\n    var canvasElement = this.graph.get('canvas').get('el');\n\n    if (this.handleWindowMouseUp) {\n      return;\n    }\n\n    this.handleWindowMouseUp = function (e) {\n      if (e.target !== canvasElement) {\n        _this.handleCanvasDragEnd();\n      }\n    };\n\n    document.body.addEventListener('mouseup', this.handleWindowMouseUp, false);\n  },\n  handleCanvasContextMenu: function handleCanvasContextMenu() {\n    this.origin = null;\n    this.dragging = false;\n  },\n  handleKeyDown: function handleKeyDown(e) {\n    this.keyCode = e.keyCode || e.which;\n  },\n  handleKeyUp: function handleKeyUp() {\n    this.keyCode = null;\n  }\n};\nbehaviorManager.register('drag-canvas', dragCanvasBehavior);\nvar recallEdgeBehavior = {\n  edgeIds: [],\n  getEvents: function getEvents() {\n    return {\n      'node:click': 'handleNodeClick',\n      'edge:click': 'handleEdgeClick',\n      'canvas:click': 'handleCanvasClick'\n    };\n  },\n  setHighLightState: function setHighLightState(edges) {\n    var graph = this.graph;\n    this.clearHighLightState();\n    executeBatch(graph, function () {\n      edges.forEach(function (item) {\n        graph.setItemState(item, ItemState.HighLight, true);\n      });\n    });\n    this.edgeIds = edges.map(function (edge) {\n      return edge.get('id');\n    });\n  },\n  clearHighLightState: function clearHighLightState() {\n    var _this = this;\n\n    var graph = this.graph;\n    executeBatch(graph, function () {\n      _this.edgeIds.forEach(function (id) {\n        var item = graph.findById(id);\n\n        if (item && !item.destroyed) {\n          graph.setItemState(item, ItemState.HighLight, false);\n        }\n      });\n    });\n    this.edgeIds = [];\n  },\n  handleNodeClick: function handleNodeClick(_ref) {\n    var item = _ref.item;\n    var graph = this.graph;\n    var edges = [];\n\n    if (isFlow(graph)) {\n      edges = getFlowRecallEdges(graph, item);\n    }\n\n    if (isMind(graph)) {\n      edges = getMindRecallEdges(graph, item);\n    }\n\n    this.setHighLightState(edges);\n  },\n  handleEdgeClick: function handleEdgeClick() {\n    this.clearHighLightState();\n  },\n  handleCanvasClick: function handleCanvasClick() {\n    this.clearHighLightState();\n  }\n};\nbehaviorManager.register('recall-edge', recallEdgeBehavior);\n\nvar GraphComponent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(GraphComponent, _React$Component);\n\n  function GraphComponent() {\n    var _this;\n\n    _this = _React$Component.apply(this, arguments) || this;\n    _this.graph = null;\n    return _this;\n  }\n\n  var _proto = GraphComponent.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.initGraph();\n    this.bindEvent();\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var data = this.props.data;\n\n    if (data !== prevProps.data) {\n      this.changeData(data);\n    }\n  };\n\n  _proto.focusRootNode = function focusRootNode(graph, data) {\n    if (!isMind(graph)) {\n      return;\n    }\n\n    var id = data.id;\n    graph.focusItem(id);\n  };\n\n  _proto.initGraph = function initGraph() {\n    var _this$props = this.props,\n        containerId = _this$props.containerId,\n        parseData = _this$props.parseData,\n        initGraph = _this$props.initGraph,\n        setGraph = _this$props.setGraph,\n        commandManager = _this$props.commandManager;\n\n    var _ref = document.getElementById(containerId) || {},\n        _ref$clientWidth = _ref.clientWidth,\n        clientWidth = _ref$clientWidth === void 0 ? 0 : _ref$clientWidth,\n        _ref$clientHeight = _ref.clientHeight,\n        clientHeight = _ref$clientHeight === void 0 ? 0 : _ref$clientHeight; // 解析数据\n\n\n    var data = _extends({}, this.props.data);\n\n    parseData(data); // 初始画布\n\n    this.graph = initGraph(clientWidth, clientHeight);\n    this.graph.data(data);\n    this.graph.render();\n    this.focusRootNode(this.graph, data);\n    this.graph.setMode('default');\n    setGraph(this.graph); // 设置命令管理器\n\n    this.graph.set('commandManager', commandManager); // 注册命令\n\n    var commands = baseCommands;\n\n    if (isMind(this.graph)) {\n      commands = _extends({}, commands, mindCommands);\n    }\n\n    Object.keys(commands).forEach(function (name) {\n      commandManager.register(name, commands[name]);\n    }); // 发送埋点\n\n    if (global.trackable) {\n      var graphType = isMind(this.graph) ? GraphType.Mind : GraphType.Flow;\n      track(graphType);\n    }\n  };\n\n  _proto.bindEvent = function bindEvent() {\n    var graph = this.graph,\n        props = this.props;\n\n    if (!graph) {\n      return;\n    }\n\n    var events = _extends({}, GraphCommonEvent, GraphNodeEvent, GraphEdgeEvent, GraphCanvasEvent, GraphCustomEvent);\n\n    Object.keys(events).forEach(function (event) {\n      if (typeof props[event] === 'function') {\n        graph.on(events[event], props[event]);\n      }\n    });\n  };\n\n  _proto.changeData = function changeData(data) {\n    var graph = this.graph;\n    var parseData = this.props.parseData;\n\n    if (!graph) {\n      return;\n    }\n\n    parseData(data);\n    graph.changeData(data);\n    this.focusRootNode(graph, data);\n  };\n\n  _proto.render = function render() {\n    var _this$props2 = this.props,\n        containerId = _this$props2.containerId,\n        children = _this$props2.children;\n    return (\n      /*#__PURE__*/\n      React.createElement(\"div\", Object.assign({\n        id: containerId\n      }, pick(this.props, ['className', 'style'])), children)\n    );\n  };\n\n  return GraphComponent;\n}(React.Component);\n\nvar GraphComponent$1 = withEditorPrivateContext(GraphComponent);\nvar dragAddNodeBehavior = {\n  shape: null,\n  graphType: GraphType.Flow,\n  graphMode: GraphMode.AddNode,\n  getEvents: function getEvents() {\n    return {\n      'canvas:mouseenter': 'handleCanvasMouseEnter',\n      mousemove: 'handleMouseMove',\n      mouseup: 'handleMouseUp'\n    };\n  },\n  handleCanvasMouseEnter: function handleCanvasMouseEnter(e) {\n    var graph = this.graph,\n        shape = this.shape;\n\n    if (shape) {\n      return;\n    }\n\n    var group = graph.get('group');\n    var model = global.component.itemPanel.model;\n    var _model$size = model.size,\n        size = _model$size === void 0 ? 100 : _model$size;\n    var width = 0;\n    var height = 0;\n\n    if (isArray(size)) {\n      width = size[0];\n      height = size[1];\n    } else {\n      width = size;\n      height = size;\n    }\n\n    var x = e.x - width / 2;\n    var y = e.y - height / 2;\n    this.shape = group.addShape('rect', {\n      className: global.component.itemPanel.delegateShapeClassName,\n      attrs: {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        fill: '#f3f9ff',\n        fillOpacity: 0.5,\n        stroke: '#1890ff',\n        strokeOpacity: 0.9,\n        lineDash: [5, 5]\n      }\n    });\n    graph.paint();\n  },\n  handleMouseMove: function handleMouseMove(e) {\n    var graph = this.graph;\n\n    var _this$shape$getBBox = this.shape.getBBox(),\n        width = _this$shape$getBBox.width,\n        height = _this$shape$getBBox.height;\n\n    var x = e.x - width / 2;\n    var y = e.y - height / 2;\n    this.shape.attr({\n      x: x,\n      y: y\n    });\n    graph.paint();\n  },\n  handleMouseUp: function handleMouseUp(e) {\n    var graph = this.graph;\n\n    var _this$shape$getBBox2 = this.shape.getBBox(),\n        width = _this$shape$getBBox2.width,\n        height = _this$shape$getBBox2.height;\n\n    var x = e.x;\n    var y = e.y;\n    var model = global.component.itemPanel.model;\n\n    if (model.center === 'topLeft') {\n      x -= width / 2;\n      y -= height / 2;\n    }\n\n    this.shape.remove(true);\n    var commandManager = graph.get('commandManager');\n    commandManager.execute(graph, EditorCommand.Add, {\n      type: ItemType.Node,\n      model: _extends({\n        id: guid(),\n        x: x,\n        y: y\n      }, model)\n    });\n  }\n};\nbehaviorManager.register('drag-add-node', dragAddNodeBehavior);\nvar dragAddEdgeBehavior = {\n  edge: null,\n  graphType: GraphType.Flow,\n  getDefaultCfg: function getDefaultCfg() {\n    return {\n      edgeType: 'bizFlowEdge',\n      getAnchorPointStateOfSourceNode: function getAnchorPointStateOfSourceNode() {\n        return AnchorPointState.Enabled;\n      },\n      getAnchorPointStateOfTargetNode: function getAnchorPointStateOfTargetNode() {\n        return AnchorPointState.Enabled;\n      }\n    };\n  },\n  getEvents: function getEvents() {\n    return {\n      'node:mouseenter': 'handleNodeMouseEnter',\n      'node:mouseleave': 'handleNodeMouseLeave',\n      'node:mousedown': 'handleNodeMouseDown',\n      mousemove: 'handleMouseMove',\n      mouseup: 'handleMouseUp'\n    };\n  },\n  isEnabledAnchorPoint: function isEnabledAnchorPoint(e) {\n    var target = e.target;\n    return !!target.get('isAnchorPoint') && target.get('anchorPointState') === AnchorPointState.Enabled;\n  },\n  isNotSelf: function isNotSelf(e) {\n    var edge = this.edge;\n    var item = e.item;\n    return item.getModel().id !== edge.getSource().getModel().id;\n  },\n  getTargetNodes: function getTargetNodes(sourceId) {\n    var graph = this.graph;\n    var nodes = graph.getNodes();\n    return nodes.filter(function (node) {\n      return node.getModel().id !== sourceId;\n    });\n  },\n  canFindTargetAnchorPoint: function canFindTargetAnchorPoint(e) {\n    return this.isEnabledAnchorPoint(e) && this.isNotSelf(e);\n  },\n  shouldAddDelegateEdge: function shouldAddDelegateEdge(e) {\n    return this.isEnabledAnchorPoint(e);\n  },\n  shouldAddRealEdge: function shouldAddRealEdge() {\n    var edge = this.edge;\n    var target = edge.getTarget();\n    return !isPlainObject(target);\n  },\n  handleNodeMouseEnter: function handleNodeMouseEnter(e) {\n    var graph = this.graph,\n        getAnchorPointStateOfSourceNode = this.getAnchorPointStateOfSourceNode;\n    var sourceNode = e.item;\n    var sourceAnchorPoints = sourceNode.getAnchorPoints();\n    var sourceAnchorPointsState = [];\n    sourceAnchorPoints.forEach(function (sourceAnchorPoint) {\n      sourceAnchorPointsState.push(getAnchorPointStateOfSourceNode(sourceNode, sourceAnchorPoint));\n    });\n    sourceNode.set('anchorPointsState', sourceAnchorPointsState);\n    graph.setItemState(sourceNode, ItemState.ActiveAnchorPoints, true);\n  },\n  handleNodeMouseLeave: function handleNodeMouseLeave(e) {\n    var graph = this.graph,\n        edge = this.edge;\n    var item = e.item;\n\n    if (!edge) {\n      item.set('anchorPointsState', []);\n      graph.setItemState(item, ItemState.ActiveAnchorPoints, false);\n    }\n  },\n  handleNodeMouseDown: function handleNodeMouseDown(e) {\n    if (!this.shouldBegin(e) || !this.shouldAddDelegateEdge(e)) {\n      return;\n    }\n\n    var graph = this.graph,\n        edgeType = this.edgeType,\n        getAnchorPointStateOfTargetNode = this.getAnchorPointStateOfTargetNode;\n    var target = e.target;\n    var sourceNode = e.item;\n    var sourceNodeId = sourceNode.getModel().id;\n    var sourceAnchorPointIndex = target.get('anchorPointIndex');\n    var sourceAnchorPoint = sourceNode.getAnchorPoints()[sourceAnchorPointIndex];\n    var model = {\n      id: guid(),\n      type: edgeType,\n      source: sourceNodeId,\n      sourceAnchor: sourceAnchorPointIndex,\n      target: {\n        x: e.x,\n        y: e.y\n      }\n    };\n    this.edge = graph.addItem(ItemType.Edge, model);\n    graph.getNodes().forEach(function (targetNode) {\n      if (targetNode.getModel().id === sourceNodeId) {\n        return;\n      }\n\n      var targetAnchorPoints = targetNode.getAnchorPoints();\n      var targetAnchorPointsState = [];\n      targetAnchorPoints.forEach(function (targetAnchorPoint) {\n        targetAnchorPointsState.push(getAnchorPointStateOfTargetNode(sourceNode, sourceAnchorPoint, targetNode, targetAnchorPoint));\n      });\n      targetNode.set('anchorPointsState', targetAnchorPointsState);\n      graph.setItemState(targetNode, ItemState.ActiveAnchorPoints, true);\n    });\n  },\n  handleMouseMove: function handleMouseMove(e) {\n    var graph = this.graph,\n        edge = this.edge;\n\n    if (!edge) {\n      return;\n    }\n\n    if (this.canFindTargetAnchorPoint(e)) {\n      var item = e.item,\n          target = e.target;\n      var targetId = item.getModel().id;\n      var targetAnchor = target.get('anchorPointIndex');\n      graph.updateItem(edge, {\n        target: targetId,\n        targetAnchor: targetAnchor\n      });\n    } else {\n      graph.updateItem(edge, {\n        target: {\n          x: e.x,\n          y: e.y\n        },\n        targetAnchor: undefined\n      });\n    }\n  },\n  handleMouseUp: function handleMouseUp() {\n    var graph = this.graph,\n        edge = this.edge;\n\n    if (!edge) {\n      return;\n    }\n\n    if (!this.shouldAddRealEdge()) {\n      graph.removeItem(this.edge);\n    }\n\n    graph.emit(GraphCustomEvent.onAfterConnect, {\n      edge: this.edge\n    });\n    this.edge = null;\n    graph.getNodes().forEach(function (node) {\n      node.set('anchorPointsState', []);\n      graph.setItemState(node, ItemState.ActiveAnchorPoints, false);\n    });\n  }\n};\nbehaviorManager.register('drag-add-edge', dragAddEdgeBehavior);\n\nvar Flow =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(Flow, _React$Component);\n\n  function Flow() {\n    var _this;\n\n    _this = _React$Component.apply(this, arguments) || this;\n    _this.graph = null;\n    _this.containerId = FLOW_CONTAINER_ID + \"_\" + guid();\n\n    _this.canDragNode = function (e) {\n      return !['anchor', 'banAnchor'].some(function (item) {\n        return item === e.target.get('className');\n      });\n    };\n\n    _this.canDragOrZoomCanvas = function () {\n      var _assertThisInitialize = _assertThisInitialized(_this),\n          graph = _assertThisInitialize.graph;\n\n      if (!graph) {\n        return false;\n      }\n\n      return global.plugin.itemPopover.state === 'hide' && global.plugin.contextMenu.state === 'hide' && global.plugin.editableLabel.state === 'hide';\n    };\n\n    _this.parseData = function (data) {\n      var nodes = data.nodes,\n          edges = data.edges;\n      [].concat(nodes, edges).forEach(function (item) {\n        var id = item.id;\n\n        if (id) {\n          return;\n        }\n\n        item.id = guid();\n      });\n    };\n\n    _this.initGraph = function (width, height) {\n      var _assertThisInitialize2 = _assertThisInitialized(_this),\n          containerId = _assertThisInitialize2.containerId;\n\n      var _this$props = _this.props,\n          graphConfig = _this$props.graphConfig,\n          customModes = _this$props.customModes;\n      var modes = merge(behaviorManager.getRegisteredBehaviors(GraphType.Flow), {\n        \"default\": {\n          'drag-node': {\n            type: 'drag-node',\n            enableDelegate: true,\n            shouldBegin: _this.canDragNode\n          },\n          'drag-canvas': {\n            type: 'drag-canvas',\n            shouldBegin: _this.canDragOrZoomCanvas,\n            shouldUpdate: _this.canDragOrZoomCanvas\n          },\n          'zoom-canvas': {\n            type: 'zoom-canvas',\n            shouldUpdate: _this.canDragOrZoomCanvas\n          },\n          'recall-edge': 'recall-edge',\n          'brush-select': 'brush-select'\n        }\n      });\n      Object.keys(modes).forEach(function (mode) {\n        var behaviors = modes[mode];\n        modes[mode] = Object.values(customModes ? customModes(mode, behaviors) : behaviors);\n      });\n      _this.graph = new G6.Graph(_extends({\n        container: containerId,\n        width: width,\n        height: height,\n        modes: modes,\n        defaultNode: {\n          type: 'bizFlowNode'\n        },\n        defaultEdge: {\n          type: 'bizFlowEdge'\n        }\n      }, graphConfig));\n      return _this.graph;\n    };\n\n    return _this;\n  }\n\n  var _proto = Flow.prototype;\n\n  _proto.render = function render() {\n    var containerId = this.containerId,\n        parseData = this.parseData,\n        initGraph = this.initGraph;\n    return (\n      /*#__PURE__*/\n      React.createElement(GraphComponent$1, Object.assign({\n        containerId: containerId,\n        parseData: parseData,\n        initGraph: initGraph\n      }, omit(this.props, ['graphConfig', 'customModes'])))\n    );\n  };\n\n  return Flow;\n}(React.Component);\n\nFlow.defaultProps = {\n  graphConfig: {}\n};\n\nvar Mind =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(Mind, _React$Component);\n\n  function Mind() {\n    var _this;\n\n    _this = _React$Component.apply(this, arguments) || this;\n    _this.graph = null;\n    _this.containerId = MIND_CONTAINER_ID + \"_\" + guid();\n\n    _this.canDragOrZoomCanvas = function () {\n      var _assertThisInitialize = _assertThisInitialized(_this),\n          graph = _assertThisInitialize.graph;\n\n      if (!graph) {\n        return false;\n      }\n\n      return global.plugin.itemPopover.state === 'hide' && global.plugin.contextMenu.state === 'hide' && global.plugin.editableLabel.state === 'hide';\n    };\n\n    _this.canCollapseExpand = function (_ref) {\n      var target = _ref.target;\n      return target && [FOLD_BUTTON_CLASS_NAME, UNFOLD_BUTTON_CLASS_NAME].includes(target.get('className'));\n    };\n\n    _this.parseData = function (data) {\n      recursiveTraversal(data, function (item) {\n        var id = item.id;\n\n        if (id) {\n          return;\n        }\n\n        item.id = guid();\n      });\n    };\n\n    _this.initGraph = function (width, height) {\n      var _assertThisInitialize2 = _assertThisInitialized(_this),\n          containerId = _assertThisInitialize2.containerId;\n\n      var _this$props = _this.props,\n          graphConfig = _this$props.graphConfig,\n          customModes = _this$props.customModes;\n      var modes = merge(behaviorManager.getRegisteredBehaviors(GraphType.Mind), {\n        \"default\": {\n          'click-item': {\n            type: 'click-item',\n            multiple: false\n          },\n          'collapse-expand': {\n            type: 'collapse-expand',\n            shouldBegin: _this.canCollapseExpand\n          },\n          'drag-canvas': {\n            type: 'drag-canvas',\n            shouldBegin: _this.canDragOrZoomCanvas,\n            shouldUpdate: _this.canDragOrZoomCanvas\n          },\n          'zoom-canvas': {\n            type: 'zoom-canvas',\n            shouldUpdate: _this.canDragOrZoomCanvas\n          }\n        }\n      });\n      Object.keys(modes).forEach(function (mode) {\n        var behaviors = modes[mode];\n        modes[mode] = Object.values(customModes ? customModes(mode, behaviors) : behaviors);\n      });\n      _this.graph = new G6.TreeGraph(_extends({\n        container: containerId,\n        width: width,\n        height: height,\n        modes: modes,\n        layout: {\n          type: 'mindmap',\n          direction: 'H',\n          getWidth: function getWidth() {\n            return 120;\n          },\n          getHeight: function getHeight() {\n            return 60;\n          },\n          getHGap: function getHGap() {\n            return 100;\n          },\n          getVGap: function getVGap() {\n            return 50;\n          },\n          getSide: function getSide(_ref2) {\n            var data = _ref2.data;\n\n            if (data.side) {\n              return data.side;\n            }\n\n            return 'right';\n          }\n        },\n        animate: false,\n        defaultNode: {\n          type: 'bizMindNode'\n        },\n        defaultEdge: {\n          type: 'bizMindEdge'\n        }\n      }, graphConfig));\n      return _this.graph;\n    };\n\n    return _this;\n  }\n\n  var _proto = Mind.prototype;\n\n  _proto.render = function render() {\n    var containerId = this.containerId,\n        parseData = this.parseData,\n        initGraph = this.initGraph;\n    var data = this.props.data;\n    return (\n      /*#__PURE__*/\n      React.createElement(GraphComponent$1, Object.assign({\n        containerId: containerId,\n        data: data,\n        parseData: parseData,\n        initGraph: initGraph\n      }, omit(this.props, ['graphConfig', 'customModes'])))\n    );\n  };\n\n  return Mind;\n}(React.Component);\n\nMind.defaultProps = {\n  graphConfig: {}\n};\n\nvar Command =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(Command, _React$Component);\n\n  function Command() {\n    var _this;\n\n    _this = _React$Component.apply(this, arguments) || this;\n    _this.state = {\n      disabled: false\n    };\n\n    _this.handleClick = function () {\n      var _this$props = _this.props,\n          name = _this$props.name,\n          executeCommand = _this$props.executeCommand;\n      executeCommand(name);\n    };\n\n    return _this;\n  }\n\n  var _proto = Command.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    var _this$props2 = this.props,\n        graph = _this$props2.graph,\n        name = _this$props2.name;\n    var commandManager = graph.get('commandManager');\n    this.setState({\n      disabled: !commandManager.canExecute(graph, name)\n    });\n    graph.on(EditorEvent.onGraphStateChange, function () {\n      _this2.setState({\n        disabled: !commandManager.canExecute(graph, name)\n      });\n    });\n  };\n\n  _proto.render = function render() {\n    var graph = this.props.graph;\n\n    if (!graph) {\n      return null;\n    }\n\n    var _this$props3 = this.props,\n        className = _this$props3.className,\n        disabledClassName = _this$props3.disabledClassName,\n        children = _this$props3.children;\n    var disabled = this.state.disabled;\n    return (\n      /*#__PURE__*/\n      React.createElement(\"div\", {\n        className: \"\" + className + (disabled ? \" \" + disabledClassName : ''),\n        onClick: this.handleClick\n      }, children)\n    );\n  };\n\n  return Command;\n}(React.Component);\n\nCommand.defaultProps = {\n  className: 'command',\n  disabledClassName: 'command-disabled'\n};\nvar index$2 = withEditorContext(Command);\n\nvar Item =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(Item, _React$Component);\n\n  function Item() {\n    var _this;\n\n    _this = _React$Component.apply(this, arguments) || this;\n\n    _this.handleMouseDown = function () {\n      var _this$props = _this.props,\n          graph = _this$props.graph,\n          type = _this$props.type,\n          model = _this$props.model;\n\n      if (type === ItemType.Node) {\n        global.component.itemPanel.model = model;\n        graph.setMode(GraphMode.AddNode);\n      }\n    };\n\n    return _this;\n  }\n\n  var _proto = Item.prototype;\n\n  _proto.render = function render() {\n    var children = this.props.children;\n    return (\n      /*#__PURE__*/\n      React.createElement(\"div\", Object.assign({}, pick(this.props, ['style', 'className']), {\n        onMouseDown: this.handleMouseDown\n      }), children)\n    );\n  };\n\n  return Item;\n}(React.Component);\n\nItem.defaultProps = {\n  type: ItemType.Node\n};\nvar Item$1 = withEditorContext(Item);\n\nvar ItemPanel =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(ItemPanel, _React$Component);\n\n  function ItemPanel() {\n    var _this;\n\n    _this = _React$Component.apply(this, arguments) || this;\n\n    _this.handleMouseUp = function () {\n      var graph = _this.props.graph;\n\n      if (graph.getCurrentMode() === GraphMode.Default) {\n        return;\n      }\n\n      var group = graph.get('group');\n      var shape = group.findByClassName(global.component.itemPanel.delegateShapeClassName);\n\n      if (shape) {\n        shape.remove(true);\n        graph.paint();\n      }\n\n      global.component.itemPanel.model = null;\n      graph.setMode(GraphMode.Default);\n    };\n\n    return _this;\n  }\n\n  var _proto = ItemPanel.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    document.addEventListener('mouseup', this.handleMouseUp, false);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    document.removeEventListener('mouseup', this.handleMouseUp, false);\n  };\n\n  _proto.render = function render() {\n    var children = this.props.children;\n    return (\n      /*#__PURE__*/\n      React.createElement(\"div\", Object.assign({}, pick(this.props, ['style', 'className'])), children)\n    );\n  };\n\n  return ItemPanel;\n}(React.Component);\n\nItemPanel.Item = Item$1;\nvar index$3 = withEditorContext(ItemPanel);\n\nvar DetailPanel = function DetailPanel() {};\n\nDetailPanel.create = function (type) {\n  return function (WrappedComponent) {\n    var TypedPanel =\n    /*#__PURE__*/\n    function (_React$Component) {\n      _inheritsLoose(TypedPanel, _React$Component);\n\n      function TypedPanel() {\n        var _this;\n\n        _this = _React$Component.apply(this, arguments) || this;\n        _this.state = {\n          graphState: GraphState.CanvasSelected\n        };\n        return _this;\n      }\n\n      var _proto = TypedPanel.prototype;\n\n      _proto.componentDidMount = function componentDidMount() {\n        var _this2 = this;\n\n        var graph = this.props.graph;\n        graph.on(EditorEvent.onGraphStateChange, function (_ref) {\n          var graphState = _ref.graphState;\n\n          _this2.setState({\n            graphState: graphState\n          });\n        });\n      };\n\n      _proto.render = function render() {\n        var graph = this.props.graph;\n        var graphState = this.state.graphState;\n\n        if (graphState !== type + \"Selected\") {\n          return null;\n        }\n\n        var nodes = getSelectedNodes(graph);\n        var edges = getSelectedEdges(graph);\n        return (\n          /*#__PURE__*/\n          React.createElement(WrappedComponent, Object.assign({\n            type: type,\n            nodes: nodes,\n            edges: edges\n          }, this.props))\n        );\n      };\n\n      return TypedPanel;\n    }(React.Component);\n\n    return withEditorContext(TypedPanel);\n  };\n};\n\nvar Register =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(Register, _React$Component);\n\n  function Register(props, type) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    var name = props.name,\n        config = props.config,\n        extend = props.extend,\n        commandManager = props.commandManager;\n\n    switch (type) {\n      case 'node':\n        G6.registerNode(name, config, extend);\n        break;\n\n      case 'edge':\n        G6.registerEdge(name, config, extend);\n        break;\n\n      case 'command':\n        commandManager.register(name, config);\n        break;\n\n      case 'behavior':\n        behaviorManager.register(name, config);\n        break;\n    }\n\n    return _this;\n  }\n\n  var _proto = Register.prototype;\n\n  _proto.render = function render() {\n    return null;\n  };\n\n  return Register;\n}(React.Component);\n\nRegister.create = function (type) {\n  var TypedRegister =\n  /*#__PURE__*/\n  function (_Register) {\n    _inheritsLoose(TypedRegister, _Register);\n\n    function TypedRegister(props) {\n      return _Register.call(this, props, type) || this;\n    }\n\n    return TypedRegister;\n  }(Register);\n\n  return withEditorPrivateContext(TypedRegister);\n};\n\nvar RegisterNode = Register.create('node');\nvar RegisterEdge = Register.create('edge');\nvar RegisterCommand = Register.create('command');\nvar RegisterBehavior = Register.create('behavior');\nvar ItemPopoverType;\n\n(function (ItemPopoverType) {\n  ItemPopoverType[\"Node\"] = \"node\";\n  ItemPopoverType[\"Edge\"] = \"edge\";\n})(ItemPopoverType || (ItemPopoverType = {}));\n\nvar ItemPopover =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(ItemPopover, _React$Component);\n\n  function ItemPopover() {\n    var _this;\n\n    _this = _React$Component.apply(this, arguments) || this;\n    _this.state = {\n      visible: false,\n      content: null\n    };\n    _this.mouseEnterTimeoutID = 0;\n    _this.mouseLeaveTimeoutID = 0;\n\n    _this.showItemPopover = function (item) {\n      var _this$props = _this.props,\n          graph = _this$props.graph,\n          renderContent = _this$props.renderContent;\n      global.plugin.itemPopover.state = 'show';\n\n      var _item$getBBox = item.getBBox(),\n          minX = _item$getBBox.minX,\n          minY = _item$getBBox.minY,\n          maxX = _item$getBBox.maxX,\n          maxY = _item$getBBox.maxY,\n          centerX = _item$getBBox.centerX,\n          centerY = _item$getBBox.centerY;\n\n      var _graph$getCanvasByPoi = graph.getCanvasByPoint(minX, minY),\n          itemMinX = _graph$getCanvasByPoi.x,\n          itemMinY = _graph$getCanvasByPoi.y;\n\n      var _graph$getCanvasByPoi2 = graph.getCanvasByPoint(maxX, maxY),\n          itemMaxX = _graph$getCanvasByPoi2.x,\n          itemMaxY = _graph$getCanvasByPoi2.y;\n\n      var _graph$getCanvasByPoi3 = graph.getCanvasByPoint(centerX, centerY),\n          itemCenterX = _graph$getCanvasByPoi3.x,\n          itemCenterY = _graph$getCanvasByPoi3.y;\n\n      var position = {\n        minX: itemMinX,\n        minY: itemMinY,\n        maxX: itemMaxX,\n        maxY: itemMaxY,\n        centerX: itemCenterX,\n        centerY: itemCenterY\n      };\n\n      _this.setState({\n        visible: true,\n        content: renderContent(item, position)\n      });\n    };\n\n    _this.hideItemPopover = function () {\n      global.plugin.itemPopover.state = 'hide';\n\n      _this.setState({\n        visible: false,\n        content: null\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = ItemPopover.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    var _this$props2 = this.props,\n        graph = _this$props2.graph,\n        type = _this$props2.type;\n\n    if (type === ItemPopoverType.Node) {\n      graph.on(GraphNodeEvent.onNodeMouseEnter, function (_ref) {\n        var item = _ref.item;\n        clearTimeout(_this2.mouseLeaveTimeoutID);\n        _this2.mouseEnterTimeoutID = delay(_this2.showItemPopover, 250, item);\n      });\n      graph.on(GraphNodeEvent.onNodeMouseLeave, function () {\n        clearTimeout(_this2.mouseEnterTimeoutID);\n        _this2.mouseLeaveTimeoutID = delay(_this2.hideItemPopover, 250);\n      });\n    }\n  };\n\n  _proto.render = function render() {\n    var graph = this.props.graph;\n    var _this$state = this.state,\n        visible = _this$state.visible,\n        content = _this$state.content;\n\n    if (!visible) {\n      return null;\n    }\n\n    return (\n      /*#__PURE__*/\n      ReactDOM.createPortal(content, graph.get('container'))\n    );\n  };\n\n  return ItemPopover;\n}(React.Component);\n\nItemPopover.defaultProps = {\n  type: ItemPopoverType.Node\n};\nvar index$4 = withEditorContext(ItemPopover);\nvar ContextMenuType;\n\n(function (ContextMenuType) {\n  ContextMenuType[\"Canvas\"] = \"canvas\";\n  ContextMenuType[\"Node\"] = \"node\";\n  ContextMenuType[\"Edge\"] = \"edge\";\n})(ContextMenuType || (ContextMenuType = {}));\n\nvar ContextMenu =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(ContextMenu, _React$Component);\n\n  function ContextMenu() {\n    var _this;\n\n    _this = _React$Component.apply(this, arguments) || this;\n    _this.state = {\n      visible: false,\n      content: null\n    };\n\n    _this.showContextMenu = function (x, y, item) {\n      var _this$props = _this.props,\n          graph = _this$props.graph,\n          renderContent = _this$props.renderContent;\n      clearSelectedState(graph);\n\n      if (item) {\n        graph.setItemState(item, ItemState.Selected, true);\n      }\n\n      global.plugin.contextMenu.state = 'show';\n      global.clipboard.point = {\n        x: x,\n        y: y\n      };\n      var position = graph.getCanvasByPoint(x, y);\n\n      _this.setState({\n        visible: true,\n        content: renderContent(item, position, _this.hideContextMenu)\n      });\n    };\n\n    _this.hideContextMenu = function () {\n      global.plugin.contextMenu.state = 'hide';\n\n      _this.setState({\n        visible: false,\n        content: null\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = ContextMenu.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    var _this$props2 = this.props,\n        graph = _this$props2.graph,\n        type = _this$props2.type;\n\n    switch (type) {\n      case ContextMenuType.Canvas:\n        graph.on(GraphCanvasEvent.onCanvasContextMenu, function (e) {\n          e.preventDefault();\n          var x = e.x,\n              y = e.y;\n\n          _this2.showContextMenu(x, y);\n        });\n        break;\n\n      case ContextMenuType.Node:\n        graph.on(GraphNodeEvent.onNodeContextMenu, function (e) {\n          e.preventDefault();\n          var x = e.x,\n              y = e.y,\n              item = e.item;\n\n          _this2.showContextMenu(x, y, item);\n        });\n        break;\n\n      case ContextMenuType.Edge:\n        graph.on(GraphEdgeEvent.onEdgeContextMenu, function (e) {\n          e.preventDefault();\n          var x = e.x,\n              y = e.y,\n              item = e.item;\n\n          _this2.showContextMenu(x, y, item);\n        });\n        break;\n    }\n\n    graph.on(GraphCommonEvent.onClick, function () {\n      _this2.hideContextMenu();\n    });\n  };\n\n  _proto.render = function render() {\n    var graph = this.props.graph;\n    var _this$state = this.state,\n        visible = _this$state.visible,\n        content = _this$state.content;\n\n    if (!visible) {\n      return null;\n    }\n\n    return (\n      /*#__PURE__*/\n      ReactDOM.createPortal(content, graph.get('container'))\n    );\n  };\n\n  return ContextMenu;\n}(React.Component);\n\nContextMenu.defaultProps = {\n  type: ContextMenuType.Canvas\n};\nvar index$5 = withEditorContext(ContextMenu);\n\nvar EditableLabel =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(EditableLabel, _React$Component);\n\n  function EditableLabel() {\n    var _this;\n\n    _this = _React$Component.apply(this, arguments) || this;\n    _this.el = null;\n    _this.state = {\n      visible: false\n    };\n\n    _this.update = function () {\n      var _this$props = _this.props,\n          graph = _this$props.graph,\n          executeCommand = _this$props.executeCommand;\n      var node = getSelectedNodes(graph)[0];\n      var model = node.getModel();\n      var label = _this.el.textContent;\n\n      if (label === model.label) {\n        return;\n      }\n\n      executeCommand('update', {\n        id: model.id,\n        updateModel: {\n          label: label\n        },\n        forceRefreshLayout: isMind(graph)\n      });\n    };\n\n    _this.showEditableLabel = function () {\n      global.plugin.editableLabel.state = 'show';\n\n      _this.setState({\n        visible: true\n      }, function () {\n        var _assertThisInitialize = _assertThisInitialized(_this),\n            el = _assertThisInitialize.el;\n\n        if (el) {\n          el.focus();\n          document.execCommand('selectAll', false, null);\n        }\n      });\n    };\n\n    _this.hideEditableLabel = function () {\n      global.plugin.editableLabel.state = 'hide';\n\n      _this.setState({\n        visible: false\n      });\n    };\n\n    _this.handleBlur = function () {\n      _this.update();\n\n      _this.hideEditableLabel();\n    };\n\n    _this.handleKeyDown = function (e) {\n      e.stopPropagation();\n      var key = e.key;\n\n      if (['Tab'].includes(key)) {\n        e.preventDefault();\n      }\n\n      if (['Enter', 'Escape', 'Tab'].includes(key)) {\n        _this.update();\n\n        _this.hideEditableLabel();\n      }\n    };\n\n    return _this;\n  }\n\n  var _proto = EditableLabel.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    var graph = this.props.graph;\n    graph.on(EditorEvent.onLabelStateChange, function (_ref) {\n      var labelState = _ref.labelState;\n\n      if (labelState === LabelState.Show) {\n        _this2.showEditableLabel();\n      } else {\n        _this2.hideEditableLabel();\n      }\n    });\n    graph.on(GraphNodeEvent.onNodeDoubleClick, function () {\n      _this2.showEditableLabel();\n    });\n  };\n\n  _proto.render = function render() {\n    var _this3 = this;\n\n    var _this$props2 = this.props,\n        graph = _this$props2.graph,\n        labelClassName = _this$props2.labelClassName,\n        labelMaxWidth = _this$props2.labelMaxWidth;\n    var mode = graph.getCurrentMode();\n    var zoom = graph.getZoom();\n\n    if (mode === GraphMode.Readonly) {\n      return null;\n    }\n\n    var node = getSelectedNodes(graph)[0];\n\n    if (!node) {\n      return null;\n    }\n\n    var model = node.getModel();\n    var group = node.getContainer();\n    var label = model.label;\n    var labelShape = group.findByClassName(labelClassName);\n\n    if (!labelShape) {\n      return null;\n    }\n\n    var visible = this.state.visible;\n\n    if (!visible) {\n      return null;\n    } // Get the label offset\n\n\n    var _labelShape$getBBox = labelShape.getBBox(),\n        relativeX = _labelShape$getBBox.x,\n        relativeY = _labelShape$getBBox.y;\n\n    var _G6$Util$applyMatrix = G6.Util.applyMatrix({\n      x: relativeX,\n      y: relativeY\n    }, node.getContainer().getMatrix()),\n        absoluteX = _G6$Util$applyMatrix.x,\n        absoluteY = _G6$Util$applyMatrix.y;\n\n    var _graph$getCanvasByPoi = graph.getCanvasByPoint(absoluteX, absoluteY),\n        left = _graph$getCanvasByPoi.x,\n        top = _graph$getCanvasByPoi.y; // Get the label size\n\n\n    var _labelShape$getBBox2 = labelShape.getBBox(),\n        width = _labelShape$getBBox2.width,\n        height = _labelShape$getBBox2.height; // Get the label font\n\n\n    var font = labelShape.attr('font');\n    var style = {\n      position: 'absolute',\n      top: top,\n      left: left,\n      width: 'auto',\n      height: 'auto',\n      minWidth: width,\n      minHeight: height,\n      maxWidth: labelMaxWidth,\n      font: font,\n      background: 'white',\n      border: '1px solid #1890ff',\n      outline: 'none',\n      transform: \"scale(\" + zoom + \")\",\n      transformOrigin: 'left top'\n    };\n    return (\n      /*#__PURE__*/\n      ReactDOM.createPortal(\n      /*#__PURE__*/\n      React.createElement(\"div\", {\n        ref: function ref(el) {\n          _this3.el = el;\n        },\n        style: style,\n        contentEditable: true,\n        onBlur: this.handleBlur,\n        onKeyDown: this.handleKeyDown,\n        suppressContentEditableWarning: true\n      }, label), graph.get('container'))\n    );\n  };\n\n  return EditableLabel;\n}(React.Component);\n\nEditableLabel.defaultProps = {\n  labelClassName: 'node-label',\n  labelMaxWidth: 100\n};\nvar index$6 = withEditorContext(EditableLabel);\nexport default Editor;\nexport { index$2 as Command, CommandManager, index$5 as ContextMenu, DetailPanel, index$6 as EditableLabel, Flow, Item$1 as Item, index$3 as ItemPanel, index$4 as ItemPopover, Mind, RegisterBehavior, RegisterCommand, RegisterEdge, RegisterNode, index$1 as Util, baseCommand, behaviorManager, index as constants, global, setAnchorPointsState, withEditorContext };","map":null,"metadata":{},"sourceType":"module"}