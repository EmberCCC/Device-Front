{"ast":null,"code":"var _excluded = [\"propsSchema\"],\n    _excluded2 = [\"schema\"];\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nimport { cloneDeep, get, isEmpty, set } from 'lodash-es';\nexport function getParamByName(name) {\n  var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location.href;\n  name = name.replace(/[\\[\\]]/g, '\\\\$&');\n  var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),\n      results = regex.exec(url);\n  if (!results) return null;\n  if (!results[2]) return '';\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '));\n} // export function isUrl(string) {\n//   const protocolRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\n//   // const domainRE = /^[^\\s\\.]+\\.\\S{2,}$/;\n//   if (typeof string !== 'string') return false;\n//   return protocolRE.test(string);\n// }\n\nexport function isCheckBoxType(schema, readOnly) {\n  if (readOnly) return false;\n  if (schema.widget === 'checkbox') return true;\n\n  if (schema && schema.type === 'boolean') {\n    if (schema.enum) return false;\n    if (schema.widget === undefined) return true;\n    return false;\n  }\n} // a[].b.c => a.b.c\n\nfunction removeBrackets(string) {\n  if (typeof string === 'string') {\n    return string.replace(/\\[\\]/g, '');\n  } else {\n    return string;\n  }\n}\n\nexport function getParentPath(path) {\n  if (typeof path === 'string') {\n    var pathArr = path.split('.');\n\n    if (pathArr.length === 1) {\n      return '#';\n    }\n\n    pathArr.pop();\n    return pathArr.join('.');\n  }\n\n  return '#';\n}\nexport function getValueByPath(formData, path) {\n  if (path === '#' || !path) {\n    return formData || {};\n  } else if (typeof path === 'string') {\n    return get(formData, path);\n  } else {\n    console.error('path has to be a string');\n  }\n} //  path: 'a.b[1].c[0]' => { id: 'a.b[].c[]'  dataIndex: [1,0] }\n\nexport function destructDataPath(path) {\n  var id;\n  var dataIndex;\n\n  if (path === '#') {\n    return {\n      id: '#',\n      dataIndex: []\n    };\n  }\n\n  if (typeof path !== 'string') {\n    throw Error(\"path \".concat(path, \" is not a string!!! Something wrong here\"));\n  }\n\n  var pattern = /\\[[0-9]+\\]/g;\n  var matchList = path.match(pattern);\n\n  if (!matchList) {\n    id = path;\n  } else {\n    id = path.replace(pattern, '[]'); // 这个是match下来的结果，可安全处理\n\n    dataIndex = matchList.map(function (item) {\n      return Number(item.substring(1, item.length - 1));\n    });\n  }\n\n  return {\n    id: id,\n    dataIndex: dataIndex\n  };\n} // id: 'a.b[].c[]'  dataIndex: [1,0] =>  'a.b[1].c[0]'\n\nexport function getDataPath(id, dataIndex) {\n  if (id === '#') {\n    return id;\n  }\n\n  if (typeof id !== 'string') {\n    throw Error(\"id \".concat(id, \" is not a string!!! Something wrong here\"));\n  }\n\n  var _id = id;\n\n  if (Array.isArray(dataIndex)) {\n    // const matches = id.match(/\\[\\]/g) || [];\n    // const count = matches.length;\n    dataIndex.forEach(function (item) {\n      _id = _id.replace(/\\[\\]/, \"[\".concat(item, \"]\"));\n    });\n  }\n\n  return removeBrackets(_id);\n}\nexport function isObjType(schema) {\n  return schema && schema.type === 'object' && schema.properties && !schema.widget;\n} // TODO: to support case that item is not an object\n\nexport function isListType(schema) {\n  return schema && schema.type === 'array' && isObjType(schema.items) && schema.enum === undefined;\n}\nexport function orderProperties(properties) {\n  var orderKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'order';\n  var orderHash = new Map(); // order不为数字的数据\n\n  var unsortedList = [];\n\n  var insert = function insert(item) {\n    var _item = _slicedToArray(item, 2),\n        value = _item[1];\n\n    if (typeof value[orderKey] !== 'number') {\n      unsortedList.push(item);\n      return;\n    }\n\n    if (orderHash.has(value[orderKey])) {\n      orderHash.get(value[orderKey]).push(item);\n    } else {\n      orderHash.set(value[orderKey], [item]);\n    }\n  };\n\n  properties.forEach(function (item) {\n    return insert(item);\n  });\n  var sortedList = Array.from(orderHash.entries()).sort(function (_ref, _ref2) {\n    var _ref3 = _slicedToArray(_ref, 1),\n        order1 = _ref3[0];\n\n    var _ref4 = _slicedToArray(_ref2, 1),\n        order2 = _ref4[0];\n\n    return order1 - order2;\n  }) // order值越小越靠前\n  .flatMap(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n        items = _ref6[1];\n\n    return items;\n  });\n  return sortedList.concat(unsortedList);\n} // TODO: more tests to make sure weird & wrong schema won't crush\n\nexport function flattenSchema() {\n  var _schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#';\n  var parent = arguments.length > 2 ? arguments[2] : undefined;\n  var result = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {}; // 排序\n  // _schema = orderBy(_schema, item => item.order, ['asc']);\n\n  var schema = clone(_schema);\n  var _name = name;\n\n  if (!schema.$id) {\n    schema.$id = _name; // path as $id, for easy access to path in schema\n  }\n\n  var children = [];\n\n  if (isObjType(schema)) {\n    orderProperties(Object.entries(schema.properties)).forEach(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 2),\n          key = _ref8[0],\n          value = _ref8[1];\n\n      var _key = isListType(value) ? key + '[]' : key;\n\n      var uniqueName = _name === '#' ? _key : _name + '.' + _key;\n      children.push(uniqueName);\n      flattenSchema(value, uniqueName, _name, result);\n    });\n    schema.properties = {};\n  }\n\n  if (isListType(schema)) {\n    orderProperties(Object.entries(schema.items.properties)).forEach(function (_ref9) {\n      var _ref10 = _slicedToArray(_ref9, 2),\n          key = _ref10[0],\n          value = _ref10[1];\n\n      var _key = isListType(value) ? key + '[]' : key;\n\n      var uniqueName = _name === '#' ? _key : _name + '.' + _key;\n      children.push(uniqueName);\n      flattenSchema(value, uniqueName, _name, result);\n    });\n    schema.items.properties = {};\n  }\n\n  if (schema.type) {\n    result[_name] = {\n      parent: parent,\n      schema: schema,\n      children: children\n    };\n  }\n\n  return result;\n}\nexport function getSchemaFromFlatten(flatten) {\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#';\n  var schema = {};\n  var item = clone(flatten[path]);\n\n  if (item) {\n    schema = item.schema; // schema.$id && delete schema.$id;\n\n    if (item.children.length > 0) {\n      item.children.forEach(function (child) {\n        if (!flatten[child]) return;\n        var key = getKeyFromPath(child);\n\n        if (isObjType(schema)) {\n          schema.properties[key] = getSchemaFromFlatten(flatten, child);\n        }\n\n        if (isListType(schema)) {\n          schema.items.properties[key] = getSchemaFromFlatten(flatten, child);\n        }\n      });\n    }\n  }\n\n  return schema;\n}\n\nfunction stringContains(str, text) {\n  return str.indexOf(text) > -1;\n}\n\nexport var isObject = function isObject(a) {\n  return stringContains(Object.prototype.toString.call(a), 'Object');\n};\nexport var clone = cloneDeep; // '3' => true, 3 => true, undefined => false\n\nexport function isLooselyNumber(num) {\n  if (typeof num === 'number') return true;\n\n  if (typeof num === 'string') {\n    return !Number.isNaN(Number(num));\n  }\n\n  return false;\n}\nexport function isCssLength(str) {\n  if (typeof str !== 'string') return false;\n  return str.match(/^([0-9])*(%|px|rem|em)$/i);\n}\nexport function isDeepEqual(param1, param2) {\n  if (param1 === undefined && param2 === undefined) return true;else if (param1 === undefined || param2 === undefined) return false;\n  if (param1 === null && param2 === null) return true;else if (param1 === null || param2 === null) return false;else if (param1.constructor !== param2.constructor) return false;\n\n  if (param1.constructor === Array) {\n    if (param1.length !== param2.length) return false;\n\n    for (var i = 0; i < param1.length; i++) {\n      if (param1[i].constructor === Array || param1[i].constructor === Object) {\n        if (!isDeepEqual(param1[i], param2[i])) return false;\n      } else if (param1[i] !== param2[i]) return false;\n    }\n  } else if (param1.constructor === Object) {\n    if (Object.keys(param1).length !== Object.keys(param2).length) return false;\n\n    for (var _i2 = 0; _i2 < Object.keys(param1).length; _i2++) {\n      var key = Object.keys(param1)[_i2];\n\n      if (param1[key] && typeof param1[key] !== 'number' && (param1[key].constructor === Array || param1[key].constructor === Object)) {\n        if (!isDeepEqual(param1[key], param2[key])) return false;\n      } else if (param1[key] !== param2[key]) return false;\n    }\n  } else if (param1.constructor === String || param1.constructor === Number) {\n    return param1 === param2;\n  }\n\n  return true;\n} // export function getFormat(format) {\n//   let dateFormat;\n//   switch (format) {\n//     case 'date':\n//       dateFormat = 'YYYY-MM-DD';\n//       break;\n//     case 'time':\n//       dateFormat = 'HH:mm:ss';\n//       break;\n//     case 'dateTime':\n//       dateFormat = 'YYYY-MM-DD HH:mm:ss';\n//       break;\n//     case 'week':\n//       dateFormat = 'YYYY-w';\n//       break;\n//     case 'year':\n//       dateFormat = 'YYYY';\n//       break;\n//     case 'quarter':\n//       dateFormat = 'YYYY-Q';\n//       break;\n//     case 'month':\n//       dateFormat = 'YYYY-MM';\n//       break;\n//     default:\n//       // dateTime\n//       if (typeof format === 'string') {\n//         dateFormat = format;\n//       } else {\n//         dateFormat = 'YYYY-MM-DD';\n//       }\n//   }\n//   return dateFormat;\n// }\n\nexport function hasRepeat(list) {\n  return list.find(function (x, i, self) {\n    return i !== self.findIndex(function (y) {\n      return JSON.stringify(x) === JSON.stringify(y);\n    });\n  });\n}\nexport function combineSchema() {\n  var propsSchema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var uiSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var propList = getChildren(propsSchema);\n  var newList = propList.map(function (p) {\n    var name = p.name;\n    var _p$schema = p.schema,\n        type = _p$schema.type,\n        options = _p$schema.enum,\n        properties = _p$schema.properties,\n        items = _p$schema.items;\n    var isObj = type === 'object' && properties;\n    var isArr = type === 'array' && items && !options; // enum + array 代表的多选框，没有sub\n\n    var ui = name && uiSchema[p.name];\n\n    if (!ui) {\n      return p;\n    } // 如果是list，递归合并items\n\n\n    if (isArr) {\n      var newItems = combineSchema(items, ui.items || {});\n      return _objectSpread(_objectSpread({}, p), {}, {\n        schema: _objectSpread(_objectSpread(_objectSpread({}, p.schema), ui), {}, {\n          items: newItems\n        })\n      });\n    } // object递归合并整个schema\n\n\n    if (isObj) {\n      var newSchema = combineSchema(p.schema, ui);\n      return _objectSpread(_objectSpread({}, p), {}, {\n        schema: newSchema\n      });\n    }\n\n    return _objectSpread(_objectSpread({}, p), {}, {\n      schema: _objectSpread(_objectSpread({}, p.schema), ui)\n    });\n  });\n  var newObj = {};\n  newList.forEach(function (s) {\n    newObj[s.name] = s.schema;\n  });\n  var topLevelUi = {};\n  Object.keys(uiSchema).forEach(function (key) {\n    if (typeof key === 'string' && key.substring(0, 3) === 'ui:') {\n      topLevelUi[key] = uiSchema[key];\n    }\n  });\n\n  if (isEmpty(newObj)) {\n    return _objectSpread(_objectSpread({}, propsSchema), topLevelUi);\n  }\n\n  return _objectSpread(_objectSpread(_objectSpread({}, propsSchema), topLevelUi), {}, {\n    properties: newObj\n  });\n} // export function isEmpty(obj) {\n//   return Object.keys(obj).length === 0;\n// }\n\nfunction getChildren(schema) {\n  if (!schema) return [];\n  var properties = schema.properties,\n      items = schema.items,\n      type = schema.type;\n\n  if (!properties && !items) {\n    return [];\n  }\n\n  var schemaSubs = {};\n\n  if (type === 'object') {\n    schemaSubs = properties;\n  }\n\n  if (type === 'array') {\n    schemaSubs = items;\n  }\n\n  return Object.keys(schemaSubs).map(function (name) {\n    return {\n      schema: schemaSubs[name],\n      name: name\n    };\n  });\n}\n\nexport var parseString = function parseString(string) {\n  return Function('\"use strict\";return (' + string + ')')();\n};\nexport var evaluateString = function evaluateString(string, formData, rootValue) {\n  return Function(\"\\\"use strict\\\";\\n    const rootValue = \".concat(JSON.stringify(rootValue), \";\\n    const formData = \").concat(JSON.stringify(formData), \";\\n    return (\").concat(string, \")\"))();\n};\nexport function isExpression(func) {\n  // if (typeof func === 'function') {\n  //   const funcString = func.toString();\n  //   return (\n  //     funcString.indexOf('formData') > -1 ||\n  //     funcString.indexOf('rootValue') > -1\n  //   );\n  // }\n  if (typeof func !== 'string') return false;\n  var pattern = /^{{(.+)}}$/;\n  var reg1 = /^{{function\\(.+}}$/; // const reg2 = /^{{(.+=>.+)}}$/;\n\n  if (typeof func === 'string' && func.match(pattern) && !func.match(reg1)) {\n    return true;\n  }\n\n  return false;\n}\nexport var parseRootValueInSchema = function parseRootValueInSchema(schema, rootValue) {\n  var result = clone(schema);\n\n  if (isObject(schema)) {\n    Object.keys(schema).forEach(function (key) {\n      var item = schema[key];\n\n      if (isObject(item)) {\n        result[key] = parseRootValueInSchema(item, rootValue);\n      } else if (typeof item === 'string') {\n        result[key] = parseSingleRootValue(item, rootValue);\n      }\n    });\n  } else {\n    console.error('schema is not an object:', schema);\n  }\n\n  return result;\n}; // handle rootValue inside List\n\nexport var parseSingleRootValue = function parseSingleRootValue(expression) {\n  var rootValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof expression === 'string' && expression.indexOf('rootValue') > 0) {\n    var funcBody = expression.substring(2, expression.length - 2);\n    var str = \"\\n    return \".concat(funcBody.replace(/rootValue/g, JSON.stringify(rootValue)));\n\n    try {\n      return Function(str)();\n    } catch (error) {\n      console.error(error, 'expression:', expression, 'rootValue:', rootValue);\n      return null; // 如果计算有错误，return null 最合适\n    }\n  } else {\n    return expression;\n  }\n};\nexport function parseSingleExpression(func) {\n  var formData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var dataPath = arguments.length > 2 ? arguments[2] : undefined;\n  var parentPath = getParentPath(dataPath);\n  var parent = getValueByPath(formData, parentPath) || {};\n\n  if (typeof func === 'string') {\n    var funcBody = func.substring(2, func.length - 2);\n    var str = \"\\n    return \".concat(funcBody.replace(/formData/g, JSON.stringify(formData)).replace(/rootValue/g, JSON.stringify(parent)));\n\n    try {\n      return Function(str)();\n    } catch (error) {\n      console.log(error, func, dataPath);\n      return null; // 如果计算有错误，return null 最合适\n    } // const funcBody = func.substring(2, func.length - 2);\n    // //TODO: 这样有问题，例如 a.b.indexOf(), 会把 a.b.indexOf 当做值\n    // const match1 = /formData.([a-zA-Z0-9.$_\\[\\]]+)/g;\n    // const match2 = /rootValue.([a-zA-Z0-9.$_\\[\\]]+)/g;\n    // const str = `\n    // return (${funcBody\n    //   .replaceAll(match1, (v, m1) =>\n    //     JSON.stringify(getValueByPath(formData, m1))\n    //   )\n    //   .replaceAll(match2, (v, m1) =>\n    //     JSON.stringify(getValueByPath(parent, m1))\n    //   )})`;\n    // try {\n    //   return Function(str)();\n    // } catch (error) {\n    //   console.log(error);\n    //   return func;\n    // }\n\n  } else return func;\n}\nexport var schemaContainsExpression = function schemaContainsExpression(schema) {\n  if (isObject(schema)) {\n    return Object.keys(schema).some(function (key) {\n      var value = schema[key];\n\n      if (typeof value === 'string') {\n        return isExpression(value);\n      } else if (isObject(value)) {\n        return schemaContainsExpression(value);\n      } else {\n        return false;\n      }\n    });\n  }\n\n  return false;\n};\nexport var parseAllExpression = function parseAllExpression(_schema, formData, dataPath) {\n  var schema = clone(_schema);\n  Object.keys(schema).forEach(function (key) {\n    var value = schema[key];\n\n    if (isObject(value)) {\n      schema[key] = parseAllExpression(value, formData, dataPath);\n    } else if (isExpression(value)) {\n      schema[key] = parseSingleExpression(value, formData, dataPath);\n    } else if (typeof key === 'string' && key.toLowerCase().indexOf('props') > -1) {\n      // 有可能叫 xxxProps\n      var propsObj = schema[key];\n\n      if (isObject(propsObj)) {\n        Object.keys(propsObj).forEach(function (k) {\n          schema[key][k] = parseSingleExpression(propsObj[k], formData, dataPath);\n        });\n      }\n    }\n  });\n  return schema;\n};\nexport function isFunctionSchema(schema) {\n  return Object.keys(schema).some(function (key) {\n    if (typeof schema[key] === 'function') {\n      return true;\n    } else if (typeof schema[key] === 'string') {\n      return isExpression(schema[key]);\n    } else if (_typeof(schema[key]) === 'object') {\n      return isFunctionSchema(schema[key]);\n    } else {\n      return false;\n    }\n  });\n}\nexport var getParentProps = function getParentProps(propName, id, flatten) {\n  try {\n    var item = flatten[id];\n    if (item.schema[propName] !== undefined) return item.schema[propName];\n\n    if (item && item.parent) {\n      var parentSchema = flatten[item.parent].schema;\n\n      if (parentSchema[propName] !== undefined) {\n        return parentSchema[propName];\n      } else {\n        return getParentProps(propName, item.parent, flatten);\n      }\n    }\n  } catch (error) {\n    return undefined;\n  }\n};\nexport var getSaveNumber = function getSaveNumber() {\n  var searchStr = localStorage.getItem('SAVES');\n\n  if (searchStr) {\n    try {\n      var saves = JSON.parse(searchStr);\n      var length = saves.length;\n      if (length) return length + 1;\n    } catch (error) {\n      return 1;\n    }\n  } else {\n    return 1;\n  }\n};\nexport function looseJsonParse(obj) {\n  return Function('\"use strict\";return (' + obj + ')')();\n}\nexport var isFunctionString = function isFunctionString(fString) {\n  return typeof fString === 'string' && fString.indexOf('function(') === 0;\n};\nexport function parseFunction(fString) {\n  if (isFunctionString(fString)) {\n    return Function('return ' + fString)();\n  }\n\n  return fString;\n} // 获得propsSchema的children\n// function getChildren2(schema) {\n//   if (!schema) return [];\n//   const {\n//     // object\n//     properties,\n//     // array\n//     items,\n//     type,\n//   } = schema;\n//   if (!properties && !items) {\n//     return [];\n//   }\n//   let schemaSubs = {};\n//   if (type === 'object') {\n//     schemaSubs = properties;\n//   }\n//   if (type === 'array') {\n//     schemaSubs = items.properties;\n//   }\n//   return Object.keys(schemaSubs).map(name => ({\n//     schema: schemaSubs[name],\n//     name,\n//   }));\n// }\n\nexport var oldSchemaToNew = function oldSchemaToNew(schema) {\n  if (schema && schema.propsSchema) {\n    var propsSchema = schema.propsSchema,\n        rest = _objectWithoutProperties(schema, _excluded);\n\n    return _objectSpread({\n      schema: propsSchema\n    }, rest);\n  }\n\n  return schema;\n};\nexport var newSchemaToOld = function newSchemaToOld(setting) {\n  if (setting && setting.schema) {\n    var schema = setting.schema,\n        rest = _objectWithoutProperties(setting, _excluded2);\n\n    return _objectSpread({\n      propsSchema: schema\n    }, rest);\n  }\n\n  return setting;\n}; // from FR\n\nexport var getEnum = function getEnum(schema) {\n  if (!schema) return undefined;\n  var itemEnum = schema && schema.items && schema.items.enum;\n  var schemaEnum = schema && schema.enum;\n  return itemEnum ? itemEnum : schemaEnum;\n}; // export const getArray = (arr, defaultValue = []) => {\n//   if (Array.isArray(arr)) return arr;\n//   return defaultValue;\n// };\n\nexport var isEmail = function isEmail(value) {\n  var regex = '^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$';\n\n  if (value && new RegExp(regex).test(value)) {\n    return true;\n  }\n\n  return false;\n};\nexport function defaultGetValueFromEvent(valuePropName) {\n  var event = arguments.length <= 1 ? undefined : arguments[1];\n\n  if (event && event.target && valuePropName in event.target) {\n    return event.target[valuePropName];\n  }\n\n  return event;\n}\nexport var getKeyFromPath = function getKeyFromPath() {\n  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '#';\n\n  try {\n    var arr = path.split('.');\n    var last = arr.slice(-1)[0];\n    var result = last.replace('[]', '');\n    return result;\n  } catch (error) {\n    console.error(error, 'getKeyFromPath');\n    return '';\n  }\n}; // 更多的值获取\n\nexport var getDisplayValue = function getDisplayValue(value, schema) {\n  if (typeof value === 'boolean') {\n    return value ? 'yes' : 'no';\n  }\n\n  if (isObjType(schema) || isListType(schema)) {\n    return '-';\n  }\n\n  if (Array.isArray(schema.enum) && Array.isArray(schema.enumNames)) {\n    try {\n      return schema.enumNames[schema.enum.indexOf(value)];\n    } catch (error) {\n      return value;\n    }\n  }\n\n  if (_typeof(value) === 'object') {\n    return JSON.stringify(value);\n  }\n\n  return value;\n}; // 去掉数组里的空元素 {a: [null, {x:1}]} => {a: [{x:1}]}\n\nexport var removeEmptyItemFromList = function removeEmptyItemFromList(formData) {\n  var result = {};\n\n  if (isObject(formData)) {\n    Object.keys(formData).forEach(function (key) {\n      result[key] = removeEmptyItemFromList(formData[key]);\n    });\n  } else if (Array.isArray(formData)) {\n    result = formData.filter(function (item) {\n      if ([false, 0, ''].indexOf(item) > -1) return true;\n\n      if (item && JSON.stringify(item) !== '{}') {\n        return true;\n      }\n\n      return false;\n    });\n  } else {\n    result = formData;\n  }\n\n  return result;\n};\nexport var getDescriptorSimple = function getDescriptorSimple() {\n  var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var path = arguments.length > 1 ? arguments[1] : undefined;\n  var result = {};\n\n  if (isObject(schema)) {\n    if (schema.type) {\n      switch (schema.type) {\n        case 'range':\n          result.type = 'array';\n          break;\n\n        case 'html':\n          result.type = 'string';\n          break;\n\n        default:\n          result.type = schema.type;\n          break;\n      }\n    }\n\n    ['pattern', 'min', 'max', 'len', 'required'].forEach(function (key) {\n      if (Object.keys(schema).indexOf(key) > -1) {\n        result[key] = schema[key];\n      }\n    });\n\n    switch (schema.format) {\n      case 'email':\n      case 'url':\n        result.type = schema.format;\n        break;\n\n      default:\n        break;\n    }\n\n    var handleRegx = function handleRegx(desc) {\n      if (desc.pattern && typeof desc.pattern === 'string') {\n        desc.pattern = new RegExp(desc.pattern);\n      }\n\n      return desc;\n    }; // result be array\n\n\n    if (schema.rules) {\n      if (Array.isArray(schema.rules)) {\n        var requiredRule = schema.rules.find(function (rule) {\n          return rule.required === true;\n        });\n\n        if (requiredRule) {\n          result = _objectSpread(_objectSpread({}, result), requiredRule);\n        }\n\n        result = [result].concat(_toConsumableArray(schema.rules));\n        result = result.map(function (r) {\n          return handleRegx(r);\n        });\n      } else if (isObject(schema.rules)) {\n        result = [result, schema.rules];\n        result = result.map(function (r) {\n          return handleRegx(r);\n        });\n      }\n    } else {\n      result = [result];\n    }\n  }\n\n  return _defineProperty({}, path, result);\n}; // _path 只供内部递归使用\n\nexport var generateDataSkeleton = function generateDataSkeleton(schema, formData) {\n  var _formData = clone(formData);\n\n  var result = _formData;\n\n  if (isObjType(schema)) {\n    if (_formData === undefined || _typeof(_formData) !== 'object') {\n      _formData = {};\n      result = {};\n    }\n\n    Object.keys(schema.properties).forEach(function (key) {\n      var childSchema = schema.properties[key];\n      var childData = _formData[key];\n      var childResult = generateDataSkeleton(childSchema, childData);\n      result[key] = childResult;\n    });\n  } else if (_formData !== undefined) {// result = _formData;\n  } else if (schema.default !== undefined) {\n    result = clone(schema.default);\n  } else if (isListType(schema)) {\n    result = [generateDataSkeleton(schema.items)];\n  } else if (schema.type === 'boolean' && !schema.widget) {\n    // result = false;\n    result = undefined;\n  } else {\n    result = undefined;\n  }\n\n  return result;\n};\nexport var translateMessage = function translateMessage(msg, schema) {\n  if (typeof msg !== 'string') {\n    return '';\n  }\n\n  if (!schema) return msg;\n  msg = msg.replace('${title}', schema.title);\n  msg = msg.replace('${type}', schema.format || schema.type); // 兼容代码\n\n  if (typeof schema.min === 'number') {\n    msg = msg.replace('${min}', schema.min);\n  }\n\n  if (typeof schema.max === 'number') {\n    msg = msg.replace('${max}', schema.max);\n  }\n\n  if (schema.rules) {\n    var minRule = schema.rules.find(function (r) {\n      return r.min !== undefined;\n    });\n\n    if (minRule) {\n      msg = msg.replace('${min}', minRule.min);\n    }\n\n    var maxRule = schema.rules.find(function (r) {\n      return r.max !== undefined;\n    });\n\n    if (maxRule) {\n      msg = msg.replace('${max}', maxRule.max);\n    }\n\n    var lenRule = schema.rules.find(function (r) {\n      return r.len !== undefined;\n    });\n\n    if (lenRule) {\n      msg = msg.replace('${len}', lenRule.len);\n    }\n\n    var patternRule = schema.rules.find(function (r) {\n      return r.pattern !== undefined;\n    });\n\n    if (patternRule) {\n      msg = msg.replace('${pattern}', patternRule.pattern);\n    }\n  }\n\n  return msg;\n};\n\nvar changeSchema = function changeSchema(_schema, singleChange) {\n  var schema = clone(_schema);\n  schema = singleChange(schema);\n\n  if (isObjType(schema)) {\n    var requiredKeys = [];\n\n    if (Array.isArray(schema.required)) {\n      requiredKeys = schema.required;\n      delete schema.required;\n    }\n\n    Object.keys(schema.properties).forEach(function (key) {\n      var item = schema.properties[key];\n\n      if (requiredKeys.indexOf(key) > -1) {\n        item.required = true;\n      }\n\n      schema.properties[key] = changeSchema(item, singleChange);\n    });\n  } else if (isListType(schema)) {\n    Object.keys(schema.items.properties).forEach(function (key) {\n      var item = schema.items.properties[key];\n      schema.items.properties[key] = changeSchema(item, singleChange);\n    });\n  }\n\n  return schema;\n};\n\nexport var updateSchemaToNewVersion = function updateSchemaToNewVersion(schema) {\n  return changeSchema(schema, updateSingleSchema);\n};\n\nvar updateSingleSchema = function updateSingleSchema(schema) {\n  try {\n    schema.rules = schema.rules || [];\n    schema.props = schema.props || {};\n\n    if (schema['ui:options']) {\n      schema.props = schema['ui:options'];\n      delete schema['ui:options'];\n    }\n\n    if (schema.pattern) {\n      var validItem = {\n        pattern: schema.pattern\n      };\n\n      if (schema.message && schema.message.pattern) {\n        validItem.message = schema.message.pattern;\n      }\n\n      schema.rules.push(validItem);\n      delete schema.pattern;\n      delete schema.message;\n    } // min / max\n\n\n    if (schema.minLength) {\n      schema.min = schema.minLength;\n      delete schema.minLength;\n    }\n\n    if (schema.maxLength) {\n      schema.max = schema.maxLength;\n      delete schema.maxLength;\n    }\n\n    if (schema.minItems) {\n      schema.min = schema.minItems;\n      delete schema.minItems;\n    }\n\n    if (schema.maxItems) {\n      schema.max = schema.maxItems;\n      delete schema.maxItems;\n    }\n\n    if (schema.step) {\n      schema.props.step = schema.step;\n      delete schema.step;\n    } // ui:xxx\n\n\n    if (schema['ui:className']) {\n      schema.className = schema['ui:className'];\n      delete schema['ui:className'];\n    }\n\n    if (schema['ui:hidden']) {\n      schema.hidden = schema['ui:hidden'];\n      delete schema['ui:hidden'];\n    }\n\n    if (schema['ui:readonly']) {\n      schema.readOnly = schema['ui:readonly']; // 改成驼峰了\n\n      delete schema['ui:readonly'];\n    }\n\n    if (schema['ui:disabled']) {\n      schema.disabled = schema['ui:disabled'];\n      delete schema['ui:disabled'];\n    }\n\n    if (schema['ui:width']) {\n      schema.width = schema['ui:width'];\n      delete schema['ui:width'];\n    }\n\n    if (schema['ui:displayType']) {\n      schema.displayType = schema['ui:displayType'];\n      delete schema['ui:displayType'];\n    }\n\n    if (schema['ui:column']) {\n      schema.column = schema['ui:column'];\n      delete schema['ui:column'];\n    }\n\n    if (schema['ui:widget']) {\n      schema.widget = schema['ui:widget'];\n      delete schema['ui:widget'];\n    }\n\n    if (schema['ui:labelWidth']) {\n      schema.labelWidth = schema['ui:labelWidth'];\n      delete schema['ui:labelWidth'];\n    }\n\n    if (schema.rules && schema.rules.length === 0) {\n      delete schema.rules;\n    }\n\n    if (typeof schema.props === 'function' || isObject(schema.props) && Object.keys(schema.props).length > 0) {} else {\n      delete schema.props;\n    }\n\n    return schema;\n  } catch (error) {\n    console.error('schema转换失败！', error);\n    return schema;\n  }\n}; // 检验一个string是 function（传统活箭头函数）\n\n\nexport var parseFunctionString = function parseFunctionString(string) {\n  if (typeof string !== 'string') return false;\n  var reg1 = /^{{(function.+)}}$/;\n  var reg2 = /^{{(.+=>.+)}}$/;\n\n  if (string.match(reg1)) {\n    return string.match(reg1)[1];\n  }\n\n  if (string.match(reg2)) {\n    return string.match(reg2)[1];\n  }\n\n  return false;\n};\nexport var completeSchemaWithTheme = function completeSchemaWithTheme() {\n  var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var theme = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var result = {};\n\n  if (isObject(schema)) {\n    if (schema.theme && theme[schema.theme]) {\n      result = _objectSpread(_objectSpread({}, schema), theme[schema.theme]);\n    }\n\n    Object.keys(schema).forEach(function (key) {\n      result[key] = completeSchemaWithTheme(schema[key], theme);\n    });\n  } else {\n    result = schema;\n  }\n\n  return result;\n};\nexport var cleanEmpty = function cleanEmpty(obj) {\n  if (Array.isArray(obj)) {\n    return obj.map(function (v) {\n      return v && isObject(v) ? cleanEmpty(v) : v;\n    }).filter(function (v) {\n      return !(v == undefined);\n    });\n  } else if (isObject(obj)) {\n    return Object.entries(obj).map(function (_ref12) {\n      var _ref13 = _slicedToArray(_ref12, 2),\n          k = _ref13[0],\n          v = _ref13[1];\n\n      return [k, v && isObject(v) ? cleanEmpty(v) : v];\n    }).reduce(function (a, _ref14) {\n      var _ref15 = _slicedToArray(_ref14, 2),\n          k = _ref15[0],\n          v = _ref15[1];\n\n      return v == undefined ? a : (a[k] = v, a);\n    }, {});\n  } else {\n    return obj;\n  }\n}; // const x = { a: 1, b: { c: 2 }, d: [{ e: 3, f: [{ g: 5 }] }, { e: 4 }] };\n// ['a', 'b.c', 'd[0].e', 'd[0].f[0].g', 'd[1].e']\n\nexport var dataToKeys = function dataToKeys(data) {\n  var rootKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var result = [];\n\n  if (rootKey && rootKey.slice(-1) !== ']') {\n    result.push(rootKey);\n  }\n\n  var isComplex = function isComplex(data) {\n    return isObject(data) || Array.isArray(data);\n  };\n\n  if (isObject(data)) {\n    Object.keys(data).forEach(function (key) {\n      var item = data[key];\n      var itemRootKey = rootKey ? rootKey + '.' + key : key;\n\n      if (isComplex(item)) {\n        var itemKeys = dataToKeys(item, itemRootKey);\n        result = [].concat(_toConsumableArray(result), _toConsumableArray(itemKeys));\n      } else {\n        result.push(itemRootKey);\n      }\n    });\n  } else if (Array.isArray(data)) {\n    data.forEach(function (item, idx) {\n      var itemRootKey = rootKey ? \"\".concat(rootKey, \"[\").concat(idx, \"]\") : \"[\".concat(idx, \"]\");\n\n      if (isComplex(item)) {\n        var itemKeys = dataToKeys(item, itemRootKey);\n        result = [].concat(_toConsumableArray(result), _toConsumableArray(itemKeys));\n      } else {\n        result.push(itemRootKey);\n      }\n    });\n  } else {}\n\n  return result;\n};\nexport var removeHiddenFromResult = function removeHiddenFromResult(data, flatten) {\n  var result = clone(data);\n  var keys = dataToKeys(result);\n  keys.forEach(function (key) {\n    var _destructDataPath = destructDataPath(key),\n        id = _destructDataPath.id,\n        dataIndex = _destructDataPath.dataIndex;\n\n    if (flatten[id]) {\n      var _ref16 = flatten[id].schema || {},\n          hidden = _ref16.hidden;\n\n      if (isExpression(hidden)) {\n        hidden = parseSingleExpression(hidden, result, key);\n      }\n\n      if (get(result, key) !== undefined && hidden) {\n        set(result, key, undefined);\n      }\n    }\n  });\n  return result;\n};\nexport function msToTime(duration) {\n  var seconds = Math.floor(duration / 1000 % 60);\n  var minutes = Math.floor(duration / (1000 * 60) % 60);\n  var hours = Math.floor(duration / (1000 * 60 * 60) % 24);\n  hours = hours < 10 ? '0' + hours : hours;\n  minutes = minutes < 10 ? '0' + minutes : minutes;\n  seconds = seconds < 10 ? '0' + seconds : seconds;\n  return hours + ':' + minutes + ':' + seconds;\n}\nexport function yymmdd(timeStamp) {\n  var date_ob = new Date(Number(timeStamp));\n\n  var adjustZero = function adjustZero(num) {\n    return ('0' + num).slice(-2);\n  };\n\n  var day = adjustZero(date_ob.getDate());\n  var month = adjustZero(date_ob.getMonth());\n  var year = date_ob.getFullYear();\n  var hours = adjustZero(date_ob.getHours());\n  var minutes = adjustZero(date_ob.getMinutes());\n  var seconds = adjustZero(date_ob.getSeconds());\n  return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \" \").concat(hours, \":\").concat(minutes, \":\").concat(seconds);\n}\nexport function allPromiseFinish(promiseList) {\n  var hasError = false;\n  var count = promiseList.length;\n  var results = [];\n\n  if (!promiseList.length) {\n    return Promise.resolve([]);\n  }\n\n  return new Promise(function (resolve, reject) {\n    promiseList.forEach(function (promise, index) {\n      promise.catch(function (e) {\n        hasError = true;\n        return e;\n      }).then(function (result) {\n        count -= 1;\n        results[index] = result;\n\n        if (count > 0) {\n          return;\n        }\n\n        if (hasError) {\n          reject(results);\n        }\n\n        resolve(results);\n      });\n    });\n  });\n}\nexport var removeDups = function removeDups(arr) {\n  if (!Array.isArray(arr)) {\n    console.log('in removeDups: param is not an array');\n    return;\n  }\n\n  var array = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (array.indexOf(arr[i]) === -1) {\n      array.push(arr[i]);\n    }\n  }\n\n  return array;\n};","map":null,"metadata":{},"sourceType":"module"}